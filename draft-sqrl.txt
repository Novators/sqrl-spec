



Internet Engineering Task Force                                A. Comley
Internet-Draft
Intended status: Informational                                S. Killian
Expires: August 30, 2018                               February 26, 2018


   Secure Quick Reliable Login (SQRL), an Authentication and Identity
                          Management Framework
                           draft-sqrl-working

Abstract

   Secure Quick Reliable Login (SQRL) is an application-level protocol
   for user authentication and identity management.  It enables a user
   to create and manage a single pseudonymous lifetime identity.  That
   identity will allow the user to securely authenticate with any SQRL
   enabled server without relying on a third party or disclosing
   personally identifiable information.

   It provides:

   o  Unique pseudonymous identifiers for each site

   o  Separation of identity management from account management

   o  Strong anti-phishing protection

   o  No shared secrets that can be exploited by bad actors

   o  Out-of-band authentication for logging in on untrusted devices

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on August 30, 2018.




Comley & Killian         Expires August 30, 2018                [Page 1]

Internet-Draft                    SQRL                     February 2018


Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  Purpose . . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.2.  Features  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.3.  Requirements Language . . . . . . . . . . . . . . . . . .   6
     1.4.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   6
   2.  Algorithms  . . . . . . . . . . . . . . . . . . . . . . . . .   8
     2.1.  Standard Algorithms . . . . . . . . . . . . . . . . . . .   8
     2.2.  base56check . . . . . . . . . . . . . . . . . . . . . . .   8
       2.2.1.  Encoding  . . . . . . . . . . . . . . . . . . . . . .   9
       2.2.2.  Validation  . . . . . . . . . . . . . . . . . . . . .  10
       2.2.3.  Decoding  . . . . . . . . . . . . . . . . . . . . . .  10
     2.3.  EnHash  . . . . . . . . . . . . . . . . . . . . . . . . .  11
     2.4.  EnScrypt  . . . . . . . . . . . . . . . . . . . . . . . .  11
   3.  Cryptographic Keys, Secrets, and Passwords  . . . . . . . . .  12
     3.1.  Class A Secrets . . . . . . . . . . . . . . . . . . . . .  12
       3.1.1.  Identity Unlock Key (IUK) . . . . . . . . . . . . . .  13
       3.1.2.  Unlock Request Signing Key (URSK) . . . . . . . . . .  13
       3.1.3.  Rescue Code (RC)  . . . . . . . . . . . . . . . . . .  13
       3.1.4.  Password Derived Keys . . . . . . . . . . . . . . . .  13
     3.2.  Class B Secrets . . . . . . . . . . . . . . . . . . . . .  14
       3.2.1.  Previous Identity Unlock Key (PIUK) . . . . . . . . .  14
       3.2.2.  Identity Master Key (IMK) . . . . . . . . . . . . . .  14
       3.2.3.  Identity Lock Key (ILK) . . . . . . . . . . . . . . .  14
       3.2.4.  Site Specific Secret Key (SSSK) . . . . . . . . . . .  15
       3.2.5.  Random Lock Key (RLK) . . . . . . . . . . . . . . . .  15
     3.3.  Class C (Public) Keys . . . . . . . . . . . . . . . . . .  15
       3.3.1.  Site Specific Public Key (SSPK) . . . . . . . . . . .  15
       3.3.2.  Server Unlock Key (SUK) . . . . . . . . . . . . . . .  15
       3.3.3.  Verify Unlock Key (VUK) . . . . . . . . . . . . . . .  15
   4.  Identity Management . . . . . . . . . . . . . . . . . . . . .  15
     4.1.  Identity Lifecycle  . . . . . . . . . . . . . . . . . . .  15



Comley & Killian         Expires August 30, 2018                [Page 2]

Internet-Draft                    SQRL                     February 2018


     4.2.  User Options  . . . . . . . . . . . . . . . . . . . . . .  16
     4.3.  Identity Storage  . . . . . . . . . . . . . . . . . . . .  17
       4.3.1.  Storage Blocks  . . . . . . . . . . . . . . . . . . .  18
       4.3.2.  Predefined Block Types  . . . . . . . . . . . . . . .  18
       4.3.3.  Encoding  . . . . . . . . . . . . . . . . . . . . . .  21
     4.4.  Identity Operations . . . . . . . . . . . . . . . . . . .  21
       4.4.1.  Identity Creation . . . . . . . . . . . . . . . . . .  22
       4.4.2.  Importing / Exporting an Identity . . . . . . . . . .  23
       4.4.3.  Changing the User's Password  . . . . . . . . . . . .  23
       4.4.4.  Identity Recovery . . . . . . . . . . . . . . . . . .  23
       4.4.5.  Rekeying an Identity  . . . . . . . . . . . . . . . .  24
   5.  Client-Server Protocol  . . . . . . . . . . . . . . . . . . .  25
     5.1.  Initiation of SQRL Authentication . . . . . . . . . . . .  25
       5.1.1.  The SQRL Scheme . . . . . . . . . . . . . . . . . . .  25
       5.1.2.  QR Codes (Out of Band)  . . . . . . . . . . . . . . .  25
     5.2.  The SQRL Realm (Domain) . . . . . . . . . . . . . . . . .  25
     5.3.  Client to Server Requests . . . . . . . . . . . . . . . .  25
       5.3.1.  Protocol Version  . . . . . . . . . . . . . . . . . .  25
       5.3.2.  Commands  . . . . . . . . . . . . . . . . . . . . . .  25
       5.3.3.  Options . . . . . . . . . . . . . . . . . . . . . . .  25
       5.3.4.  The server Value  . . . . . . . . . . . . . . . . . .  25
       5.3.5.  The client Value  . . . . . . . . . . . . . . . . . .  25
       5.3.6.  Client Keys . . . . . . . . . . . . . . . . . . . . .  26
       5.3.7.  Client Signatures . . . . . . . . . . . . . . . . . .  26
       5.3.8.  Composing the Request . . . . . . . . . . . . . . . .  26
     5.4.  Server to Client Replies  . . . . . . . . . . . . . . . .  26
       5.4.1.  Required Values . . . . . . . . . . . . . . . . . . .  26
       5.4.2.  Optional Values . . . . . . . . . . . . . . . . . . .  26
       5.4.3.  Additional Values . . . . . . . . . . . . . . . . . .  26
       5.4.4.  Composing the Reply . . . . . . . . . . . . . . . . .  26
   6.  Client-Server Interactions  . . . . . . . . . . . . . . . . .  26
     6.1.  Same Device Authentication  . . . . . . . . . . . . . . .  26
     6.2.  Cross Device Authentication . . . . . . . . . . . . . . .  26
     6.3.  Identity Association  . . . . . . . . . . . . . . . . . .  27
     6.4.  Updating Identity Association . . . . . . . . . . . . . .  27
     6.5.  Disabling Site Login  . . . . . . . . . . . . . . . . . .  27
     6.6.  Re-Enabling Site Login  . . . . . . . . . . . . . . . . .  27
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  27
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  27
     8.1.  Phishing  . . . . . . . . . . . . . . . . . . . . . . . .  27
     8.2.  Shoulder-Surfing  . . . . . . . . . . . . . . . . . . . .  29
     8.3.  Evil Router . . . . . . . . . . . . . . . . . . . . . . .  30
     8.4.  Server Compromise . . . . . . . . . . . . . . . . . . . .  30
     8.5.  CPU Flooding  . . . . . . . . . . . . . . . . . . . . . .  31
     8.6.  Evil Client . . . . . . . . . . . . . . . . . . . . . . .  31
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  32
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  32
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  33



Comley & Killian         Expires August 30, 2018                [Page 3]

Internet-Draft                    SQRL                     February 2018


   Appendix A.  Recommendations and Best Practices . . . . . . . . .  33
     A.1.  For Clients . . . . . . . . . . . . . . . . . . . . . . .  33
     A.2.  For Servers . . . . . . . . . . . . . . . . . . . . . . .  33
     A.3.  For Users . . . . . . . . . . . . . . . . . . . . . . . .  33
       A.3.1.  Master Password . . . . . . . . . . . . . . . . . . .  34
       A.3.2.  Identity Backup . . . . . . . . . . . . . . . . . . .  34
       A.3.3.  Disaster Recovery . . . . . . . . . . . . . . . . . .  34
   Appendix B.  The Optional ShortPass Feature . . . . . . . . . . .  35
   Appendix C.  Harvesting Entropy . . . . . . . . . . . . . . . . .  35
     C.1.  Entropy Sources . . . . . . . . . . . . . . . . . . . . .  36
       C.1.1.  Operating System  . . . . . . . . . . . . . . . . . .  36
       C.1.2.  Hardware  . . . . . . . . . . . . . . . . . . . . . .  36
       C.1.3.  User  . . . . . . . . . . . . . . . . . . . . . . . .  37
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  37

1.  Introduction

1.1.  Purpose

   Secure Quick Reliable Login (SQRL) is an authentication method and
   identity management framework which gives the user complete control
   over their online identity, including provisions for recovering from
   the loss of their identity file or password and recovering from
   potential security breaches.

1.2.  Features

   Secure
      Through a series of cryptographic signatures, the user can prove
      their identity without disclosing any information that would allow
      that identity to be compromised or their account hacked.  SQRL
      also provides strong anti-phishing features.

   Identity Management
      SQRL separates and delineates the concepts of account and
      identity.  SQRL provides a full identity lifecycle management
      framework which allows the user to maintain complete control of
      their identity, while leaving servers with complete control over
      account issues.  Even in the event of a compromise, the user
      retains the ability to retake control of their identity and lock
      the attacker out.  Automated rekeying means that the user can
      maintain a single SQRL identity indefinitely, even after a
      compromise.

   Global Password
      The user only has to remember a single password, which is used to
      locally decrypt their identity during SQRL authentication.  Since
      the user no longer has to remember a unique password for each



Comley & Killian         Expires August 30, 2018                [Page 4]

Internet-Draft                    SQRL                     February 2018


      site, this one global password can be very strong.  This strong
      password combined with strong encryption makes it infeasible for
      even a state level actor to compromise the user's identity.  (SQRL
      apps can alternately use other methods of protection such as
      biometrics when available on the host device.)

   Pseudononymous
      SQRL authentication is pseudonymous, in that it only provides a
      secure, site-specific token to the server.  This token cannot be
      directly linked to a user's account at any other server, and
      provides no personally identifiable information.

   No Shared Secrets
      Passwords, time-based authenticators, and other authentication
      methods work through shared secrets.  These secrets can
      conceivably be stolen by hackers or rogue employees and used to
      impersonate the user.  SQRL does not operate through shared
      secrets, and even if the server's account database is stolen the
      attacker is not given any means to impersonate the user.

   No Third Party
      The user's identity cannot be compromised by a security breach at
      a third party authentication provider, protecting it from both
      hackers and overreaching authorities.

   No Per-Site Settings
      Unlike password managers, SQRL does not require any information
      about specific websites to be saved, preventing potential privacy
      issues stemming from information leaks as well as keeping its
      database size small.

   Offline Identity Backup
      Since SQRL identities are intended to last a lifetime, and there
      is no third party that can help the user recover their identity if
      they forget their password, SQRL includes an offline backup
      mechanism.  The user can print out or write down their encrypted
      identity, along with a secure Rescue Code, that will allow the
      user to recover from a forgotten password.

   Out Of Band Authentication Option
      With SQRL, the user can safely authenticate a session on public or
      potentially compromised systems by scanning a QR code on a trusted
      mobile device containing their SQRL identity, without the need to
      expose that identity to the public system.







Comley & Killian         Expires August 30, 2018                [Page 5]

Internet-Draft                    SQRL                     February 2018


1.3.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

1.4.  Definitions

   Account
      Information on a user's services and permissions on a particular
      web site for purposes of facilitating access

   Authentication
      The process of verifying an identity and attaching it to an
      account

   Backup
      To externally save a user's Rescue Code-protected IUK via file, QR
      code, or text without saving the IMK

   Client
      The user component of SQRL

   Export
      To externally save a user's Rescue Code-protected IUK and
      password-protected IMK via file or QR code

   Identity
      A means of pseudonymously recognizing a user

   Identity Lock
      A method of locking a user's identity on various websites
      (generally out of fear the user's IMK may be compromised) for
      later unlocking with Rescue Code or rekeyed identity

   ILK
      Identity Lock Key: public key counterpart to the IUK

   IMK
      Identity Master Key: A key derived from the IUK that is the basis
      of a user's identity for each realm

   Import
      To load an exported or backed up identity into a client

   IUK
      Identity Unlock Key: the master key from which all aspects of a
      user's identity are derived



Comley & Killian         Expires August 30, 2018                [Page 6]

Internet-Draft                    SQRL                     February 2018


   Master Password
      A password created by the user that is used to derive the
      encryption key for the user's IMK

   Nut
      A unique, unpredictable, cryptographically-strong string
      identifying the current session

   Pseudonymous
      Of a consistent and reliable means of verifying a user without
      having to obtain personal information

   Realm
      The basis for generating a unique identity key; generally the
      domain name, but additional data can be included (ref)

   Rekey
      To replace a potentially-compromised IMK

   Rescue Code
      A cryptographically-strong 24 decimal digit random number that is
      used to derive the encryption key for the user's IUK

   RLK
      Random Lock Key: generated randomly by a user for a new website
      and used as the basis of the Identity Lock system

   Server
      The backend component of SQRL that verifies a user identity and
      attaches it to an account

   ShortPass
      The first few characters (4 by default) of a user's Master
      Password; used to verify the user after the Master Password has
      been used to start a session

   SSPK
      Site-Specific Public Key: a secure, irreversible, and collision-
      resistant public key used to identify the user in a specific
      realm; unique to both the realm and the user's IMK

   SUK
      Server Unlock Key: public key counterpart to the RLK; sent by the
      user to the server on account creation and used to unlock an
      identity

   VUK




Comley & Killian         Expires August 30, 2018                [Page 7]

Internet-Draft                    SQRL                     February 2018


      Verify Unlock Key: public key counterpart to a Diffie-Hellman key
      generated by the RLK and the ILK; later used to verify an unlock
      request from the user made from the SUK and the user's IUK

2.  Algorithms

   TODO

2.1.  Standard Algorithms

   The following standard algorithms are used in this document:

   o  AES-GCM [NIST.800-38D]

   o  base64url: URL safe base64 encoding, as defined in Section 4 of
      [RFC3548], without padding.

   o  Curve25519 [RFC8031]

   o  Ed25519 [RFC8032]

   o  HMAC [RFC2104]

   o  HMAC-SHA256 [RFC4868]

   o  PBKDF2 [RFC2898]

   o  scrypt [RFC7914]

   o  SHA-256 [FIPS.180-4.2015]

   o  urlencode: Percent-Encoding as defined in Section 2.1 of
      [RFC3986].

2.2.  base56check

   base56check encoding allows the backup of SQRL identities to a
   textual form.  It:

   o  Accepts an arbitrarily sized payload.

   o  Uses a set of 56 alphanumeric symbols chosen to be easily
      distinguishable in any font.

   o  Ignores invalid characters and white space to allow readable
      formatting.





Comley & Killian         Expires August 30, 2018                [Page 8]

Internet-Draft                    SQRL                     February 2018


   o  Designed to be printed 20 characters per line, in 5 space
      separated groups of 4 characters for readability.

   o  Includes a check character at the end of each line to catch errors
      while the user is typing with 98.2% accuracy.

   The chosen alphabet is:

   23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz

2.2.1.  Encoding

   To encode a series of bytes to base56check, treat the source bytes as
   a single, large, little-endian number and convert using the normal
   mathematical steps:

   1.  Calculate BASE_LENGTH: ceil( SOURCE_LENGTH * 8.0 / log2(56))

   2.  Divide SOURCE by 56 to yield SOURCE and REMAINDER.

   3.  Append the character in ALPHABET at position REMAINDER to the
       BASE string.

   4.  Repeat from step 1, until SOURCE is zero.

   5.  Append '2' (character in ALPHABET at position 0) to BASE until
       BASE is BASE_LENGTH bytes long.

   Now, with our converted BASE string, we can calculate the check
   digits and produce the final output.

   6.  Split BASE into 19 character CHUNKS (the final chunk may be
       smaller).

   7.  For each CHUNK:

       A.  Append a single byte zero-based CHUNK-NUMBER to the CHUNK.

       B.  Perform a SHA-256 hash on the CHUNK, yielding HASH.

       C.  Treating HASH as a single little-endian number, divide HASH
           by 56 to obtain REMAINDER.

       D.  Replace the last character in CHUNK with the character in
           ALPHABET at position REMAINDER.

       E.  Append the CHUNK to OUTPUT.




Comley & Killian         Expires August 30, 2018                [Page 9]

Internet-Draft                    SQRL                     February 2018


   OUTPUT can then be formatted as desired.  The RECOMMENDED formatting
   is 20 characters per line in space-separated groups of 4 characters
   each.  This format is easy for humans to read and type, and allows
   error checking for each line of input.

2.2.2.  Validation

   base56check is designed to provide periodic error checking and
   feedback to the user as they are typing.  To perform this validation:

   1.  Remove any characters from INPUT that are invalid (not included
       in ALPHABET).

   2.  Split INPUT into 20 character CHUNKS (the final chunk may be
       smaller).

   3.  For each CHUNK:

       A.  Store the last character from CHUNK as CHECK.

       B.  Replace the last character in CHUNK with a single byte zero-
           based CHUNK-NUMBER.

       C.  Perform a SHA-256 hash on the CHUNK, yielding HASH.

       D.  Treating HASH as a single little-endian number, divide HASH
           by 56 to obtain REMAINDER.

       E.  Compare CHECK with the character from ALPHABET at position
           REMAINDER.

       F.  If comparison passes (is equal), continue.  Otherwise, there
           is an error in this CHUNK.

2.2.3.  Decoding

   Decoding base56check is similarly straight-forward:

   1.  Start with an empty BASE string and an zero OUTPUT buffer, to be
       treated as a single, large, little-endian number.

   2.  Perform the base56check validation as described above, appending
       all but the last character of each validated CHUNK to the BASE
       string.

   3.  If any chunk fails validation, abort.

   4.  For each CHARACTER in BASE, from right to left:



Comley & Killian         Expires August 30, 2018               [Page 10]

Internet-Draft                    SQRL                     February 2018


       A.  Multiply OUTPUT by 56.

       B.  Lookup the INDEX of CHARACTER in ALPHABET.

       C.  Add INDEX to OUTPUT.

2.3.  EnHash

   EnHash is an iterated hash used to derive a 256 bit key from another
   256 bit key.  It is performed by chaining 16 iterations of SHA-256,
   with each iteration's output XORed to produce the final output as
   follows:

   function EnHash ( input := 32 byte key )
   {
     output := 32 byte buffer;

     set output to all NULL (0) bytes;

     repeat {
       input = SHA256( input );
       output = output XOR input;
     } 16 times;

     return output;
   }

2.4.  EnScrypt

   EnScrypt is an implementation of PBKDF2 using scrypt as a PRF.  It
   hardens scrypt by allowing for extended processing time while keeping
   memory requirements low but still effective.

   The following parameters are used for the scrypt function:

                     +-------+------------+-----+---+
                     | dkLen | N          | r   | p |
                     +-------+------------+-----+---+
                     | 32    | 512 (1<<9) | 256 | 1 |
                     +-------+------------+-----+---+

                        Table 1: scrypt parameters

   In this document, we may refer to an additional parameter, "n-factor"
   or just "n".  This is simply a shorthand way of storing the N
   parameter.  N is derived from n as follows:

   N = (1 << n);



Comley & Killian         Expires August 30, 2018               [Page 11]

Internet-Draft                    SQRL                     February 2018


   Enscrypt is performed by calling scrypt via multiple rounds of
   PBKDF2.

   EnScrypt can operate in two different modes, the only difference
   being when the calculation is stopped.

   Counter Mode:
      Stops after a predefined number of iterations.

   Timer Mode:
      Stops after a desired amount of time has passed (5 seconds by
      default).

   Timer Mode is used when creating an encryption key from a password.
   Successive rounds of PBKDF2 are computed until the specified time
   elapses.  The result is used as the key to encrypt the identity, and
   the resulting number of iterations is saved with the identity file.
   Counter Mode is used to recreate this key and decrypt the identity.

3.  Cryptographic Keys, Secrets, and Passwords

   SQRL uses a wide variety of secrets in various operations.

3.1.  Class A Secrets

   Class A secrets are absolutely critical to protecting a user's
   identity.  A compromised Class A secret may result in the user's
   complete loss of control of the identity, with no recourse available.
   Due to their highly sensitive nature, the following precautions are
   REQUIRED when dealing with Class A secrets:

   o  The secret MUST be generated using the highest quality entropy
      source available to the client.  See Appendix C for
      recommendations.

   o  The client MUST prevent the secret from being written to non-
      volatile memory in plaintext form, including being swapped to
      disk, by any means possible.

   o  The plaintext secret MUST be securely wiped from RAM as soon as it
      is no longer needed.

   o  If the secret is to be stored, it MUST be stored in an offline
      format (printed), OR encrypted using a Class A key.

   o  The secret SHOULD NOT be transmitted over the network in any form,
      and MUST NOT be transmitted unencrypted.




Comley & Killian         Expires August 30, 2018               [Page 12]

Internet-Draft                    SQRL                     February 2018


3.1.1.  Identity Unlock Key (IUK)

   IUK = RandomBytes( 32 );

   The IUK is a Class A 256 bit high entropy random number that
   represents a user's identity.  All other identifying keys are derived
   from this one.  After identity creation, this key is only used in
   emergency situations, such as rekeying an identity in the event of a
   possible compromise.

3.1.2.  Unlock Request Signing Key (URSK)

   URSK = curve25519_key_agreement( SUK, curve25519_private_key( IUK ));

   Used by the client to update the identity association on a server,
   the URSK is derived from the SUK and IUK.

3.1.3.  Rescue Code (RC)

   The Rescue Code is a Class A, computer generated, high entropy
   passcode consisting of 24 numeric digits.  The client SHOULD
   encourage the user to store the Rescue Code in an offline format
   (printed or written).

3.1.4.  Password Derived Keys

   Several keys are generated from user input.  Both the user supplied
   passwords and the derived keys are to be treated as Class A secrets.
   Since these are expected to be low entropy, they must be processed
   through EnScrypt (Section 2.4).  When generating derived keys,
   EnScrypt MUST be used in timer mode with a minimum duration of 1
   second.  The table below lists RECOMMENDED durations for EnScrypt key
   generation:

       +----------------------------+--------------+---------------+
       | Key                        | Abbreviation | EnScrypt Time |
       +----------------------------+--------------+---------------+
       | Password Derived Key       | PWDK         | 5 seconds     |
       | Short Password Derived Key | SPDK         | 1 second      |
       | Rescue Code Derived Key    | RCDK         | 60 seconds    |
       +----------------------------+--------------+---------------+

       Table 2: Password Derived Keys and Recommended EnScrypt Times

   Clients MAY allow the user to specify the EnScrypt time for the PWDK,
   as long as that timer is at least 1 second.  The RCDK is used so
   rarely, and is so important to protect, that 60 seconds should not
   cause an undue burden on the user.



Comley & Killian         Expires August 30, 2018               [Page 13]

Internet-Draft                    SQRL                     February 2018


   When re-generating derived keys, EnScrypt is used in counter mode
   with the iteration count from the original generation operation.

3.2.  Class B Secrets

   Class B secrets are used often, and have less strict security
   requirements.  A compromised Class B secret may result in an attacker
   temporarily gaining the ability to impersonate the user to any
   server, but the user can regain control of their identity by rekeying
   followed by authenticating with each affected server.  The following
   precautions are REQUIRED when dealing with Class B secrets:

   o  The client MUST prevent the secret from being written to non-
      volatile memory in plaintext form, including being swapped to
      disk, by any means possible.

   o  The plaintext secret MUST be securely wiped from RAM as soon as it
      is no longer needed.

   o  If the secret is to be stored, it MUST be stored in an encrypted
      form.

   o  The secret SHOULD NOT be transmitted over the network in any form,
      and MUST NOT be transmitted unencrypted.

3.2.1.  Previous Identity Unlock Key (PIUK)

   A PIUK is an IUK that is no longer in active use.  It has been
   replaced by a newly generated IUK, and requires less strict
   protection.

3.2.2.  Identity Master Key (IMK)

   IMK = EnHash( IUK );

   This Class B key acts as a proxy for the IUK during normal SQRL
   operation.  It is used to generate the unique keys that each site
   associates with the user.  The IMK is derived from the IUK using the
   EnHash (Section 2.3) function.

3.2.3.  Identity Lock Key (ILK)

   ILK = curve25519_public_key( curve25519_private_key( IUK ));

   The (modified) IUK and ILK together form a Curve25519 key pair.






Comley & Killian         Expires August 30, 2018               [Page 14]

Internet-Draft                    SQRL                     February 2018


3.2.4.  Site Specific Secret Key (SSSK)

   SSSK = HMAC-SHA256( IMK, Realm );

   The Site Specific Secret Key is generated from the IMK and the Realm
   (Section 5.2).

3.2.5.  Random Lock Key (RLK)

   RLK = curve25519_private_key( RandomBytes( 32 ));

   The RLK is generated randomly when the client associates with a new
   server.

3.3.  Class C (Public) Keys

   Class C keys are not required to be kept secret.

3.3.1.  Site Specific Public Key (SSPK)

   SSPK = ed25519_public_key( SSSK );

   The Site Specific Public Key (SSPK) is the public counterpart to the
   SSSK.  It serves as the user's pseudonymous identity on the site.

3.3.2.  Server Unlock Key (SUK)

   SUK = curve25519_public_key( RLK );

   Created during identity association, the SUK is the public
   counterpart of the RLK.

3.3.3.  Verify Unlock Key (VUK)

   VUK = ed25519_public_key( curve25519_key_agreement( ILK, RLK ));

   Generated during identity association, and stored only on the server,
   the VUK is the public key used to verify the client's URSK.

4.  Identity Management

4.1.  Identity Lifecycle

   TODO







Comley & Killian         Expires August 30, 2018               [Page 15]

Internet-Draft                    SQRL                     February 2018


4.2.  User Options

   Several user options are available which will affect the operation of
   compatible SQRL clients:

   ShortPass Length:
      The number of characters from the user's password to use as the
      ShortPass (Appendix B).  Clients that implement ShortPass MUST
      honor the user's choice here.  Valid values are 0 to 255.  A value
      of 0 disables the ShortPass feature.

   EnScrypt Seconds:
      The number of seconds to run EnScrypt when deriving the PWDK.  The
      RECOMMENDED default is 5 seconds.  The REQUIRED minimum is 1
      second.

   Idle Timeout:
      If the client implements ShortPass or holds the user's password or
      keys in memory in any form, and the 0x0080 option flag is set, it
      MUST securely erase that memory after this many minutes of system
      idle time.  Valid values are 1-65535.

   Option Flags:
      The following binary flags turn on or off various user options:



























Comley & Killian         Expires August 30, 2018               [Page 16]

Internet-Draft                    SQRL                     February 2018


   +--------+----------------------------------------------------------+
   | Flag   | Description                                              |
   +--------+----------------------------------------------------------+
   | 0x0001 | Check for updates:  Gives the client permission to       |
   |        | periodically check for updates.                          |
   | 0x0002 | Update Automatically:  Requests that the client          |
   |        | automatically update itself when a new version is        |
   |        | available.                                               |
   | 0x0004 | Request SQRL only:  Requests that servers disable other  |
   |        | means of authentication and only allow SQRL.             |
   | 0x0008 | Request no bypass:  Requests that servers not allow non- |
   |        | SQRL account recovery options.                           |
   | 0x0010 | Warn of possible MITM attack: The client will warn the   |
   |        | user if their IP doesn't match the server's              |
   |        | expectations.                                            |
   | 0x0020 | Clear ShortPass when screen blanks: The client will      |
   |        | securely erase any ShortPass information when the screen |
   |        | saver is activated or the system is going to suspend /   |
   |        | sleep modes.                                             |
   | 0x0040 | Clear ShortPass when changing users: The client will     |
   |        | securely erase any ShortPass information when the        |
   |        | system's active user changes.                            |
   | 0x0080 | Clear ShortPass after idle timer: The client will        |
   |        | securely erase any ShortPass information after the       |
   |        | system has been idle for an amount of time specified in  |
   |        | the "Idle Timeout" option.                               |
   | 0x0100 | Warn of non-CPS authentication: The client will warn the |
   |        | user before a non-CPS authentication is attempted.  This |
   |        | flag MUST default to on.                                 |
   +--------+----------------------------------------------------------+

                             User Option Flags

4.3.  Identity Storage

   Because SQRL identities are intended to last the user's lifetime, the
   user needs to be able to move his identity between clients.  Every
   SQRL client MUST be able to read and write identities in this
   standard format.  The format described here is RECOMMENDED for both
   non-volatile and in-memory storage.

   Because identities should be backed up offline (to printed paper),
   the storage format must be compact enough to reliably fit in a
   printed QR code, and short enough to not cause undue burden if the
   user has to type it in by hand.

   Values stored in standard SQRL storage format MUST follow these
   rules:



Comley & Killian         Expires August 30, 2018               [Page 17]

Internet-Draft                    SQRL                     February 2018


   o  All numeric values are unsigned.

   o  Multibyte numeric values are stored in little endian byte order,
      with the least significant byte first.

   o  String values are stored in natural order, first byte first.

4.3.1.  Storage Blocks

   A stored SQRL identity is composed of any number of blocks.  Each
   block begins with a four byte header identifying the total length of
   the block and the type of data stored in the block.

              +-----------------------------+--------------+
              | Field                       | Size (bytes) |
              +-----------------------------+--------------+
              | block length in bytes (n+4) | 2            |
              | block type                  | 2            |
              | block data                  | n            |
              +-----------------------------+--------------+

                       Table 3: Storage Block Format

   Standard block types are defined in the next section.  Clients MAY
   add their own block types to store additional information, but SHOULD
   consider types 0-255 as reserved for future official block types.
   Any client reading an identity that encouters a block type unknown to
   that client MUST simply ignore that block.

4.3.2.  Predefined Block Types

4.3.2.1.  Block Type 1: Working Identity

   The type 1 block contains the user's encrypted IMK and ILK, as well
   as user defined options.  The user options are in plain text, but
   MUST be regarded as untrusted until authenticated through AES-GCM.
   Type 1 blocks are encrypted with AES-GCM using the PWDK.  The type 1
   block is formatted as follows:













Comley & Killian         Expires August 30, 2018               [Page 18]

Internet-Draft                    SQRL                     February 2018


              +--------------------------+---------+-------+
              | Field                    | Default | Bytes |
              +--------------------------+---------+-------+
              | Block Length             | 125     |     2 |
              | Block Type               | 1       |     2 |
              | AAD Length               | 45      |     2 |
              | AES-GCM IV               |         |    12 |
              | EnScrypt Salt            |         |    16 |
              | EnScrypt n-factor        | 9       |     1 |
              | EnScrypt Iteration Count |         |     4 |
              | User Option Flags        | 0x01F3  |     2 |
              | ShortPass Length         | 4       |     1 |
              | EnScrypt Seconds         | 5       |     1 |
              | Idle Timeout (minutes)   | 15      |     2 |
              | Encrypted IMK            |         |    32 |
              | Encrypted ILK            |         |    32 |
              | AES-GCM Verification Tag |         |    16 |
              +--------------------------+---------+-------+

                               Type 1 Block

   Constructing a type 1 block is relatively straight-forward:

   1.  Allocate a 125 byte buffer.

   2.  Populate the default values (or user chosen options).

   3.  Generate a random 12 byte initialization vector (IV) and store it
       in the buffer.

   4.  Generate a random 16 byte salt and store it in the buffer.

   5.  Use the generated salt, the user's password, and the user's
       chosen EnScrypt Seconds value to generate the PWDK and Iteration
       Count.

   6.  Populate the Iteration Count in the buffer.

   7.  AES-GCM encrypt the IMK and ILK (64 bytes total) using the first
       "AAD Length" bytes of the buffer as AAD, the IV, the PWDK.

   8.  Populate the ciphertext result and verification tag from AES-GCM.

   9.  Securely wipe the plaintext keys, encryption key, and password
       from memory if they are no longer needed.






Comley & Killian         Expires August 30, 2018               [Page 19]

Internet-Draft                    SQRL                     February 2018


   If the client is updating a type 1 block, and the user's password
   hasn't changed, clients SHOULD use the original salt and iteration
   count to re-encrypt the block.

4.3.2.2.  Block Type 2: Rescue Identity

   The type 2 block contains a single key, the IUK, along with it's
   encryption parameters.  It is encrypted with AES-GCM using the RCDK.

              +--------------------------+---------+-------+
              | Field                    | Default | Bytes |
              +--------------------------+---------+-------+
              | Block Length             | 73      | 2     |
              | Block Type               | 2       | 2     |
              | EnScrypt Salt            |         | 16    |
              | EnScrypt n-factor        | 9       | 1     |
              | EnScrypt Iteration Count |         | 4     |
              | Encrypted IUK            |         | 32    |
              | AES-GCM Verification Tag |         | 16    |
              +--------------------------+---------+-------+

                               Type 2 Block

   The type 2 block is constructed the same way as the type 1, with the
   following exceptions:

   o  To save space in textual exports, we implicitly use a 12 byte, all
      zero Initialization Vector for AES-GCM.  This means that the type
      2 block MUST NOT be re-encrypted with different parameters.  This
      block MUST NOT be changed after identity creation.  It can only be
      replaced by rekeying.

   o  The RCDK is used in place of the PWDK.

4.3.2.3.  Block Type 3: Previous Identities

   The type 3 block contains from one to four of the most recent PIUKs,
   IUKs which have been replaced by rekeying.  It also includes the
   total number of times the identity has been rekeyed, the "Edition".
   If the identity has never been rekeyed, this block will be absent.
   Encrypted using the IMK as the AES-GCM encryption key, the content of
   this block is accessible to the client if either the user's password
   or the Rescue Code is known.








Comley & Killian         Expires August 30, 2018               [Page 20]

Internet-Draft                    SQRL                     February 2018


   +------------------------+---------------------+--------------------+
   | Field                  | Default             | Bytes              |
   +------------------------+---------------------+--------------------+
   | Block Length           | 54, 86, 118, or 150 | 2                  |
   | Block Type             | 3                   | 2                  |
   | Edition                |                     | 2                  |
   | Previous IUKs          |                     | 32, 64, 96, or 128 |
   | AES-GCM Verification   |                     | 16                 |
   | Tag                    |                     |                    |
   +------------------------+---------------------+--------------------+

                               Type 3 Block

   The type 3 block is encrypted with AES-GCM, using the first 6 bytes
   of the block as AAD, the IMK as the encryption key, and a 12 byte all
   zero initialization vector (IV).  Due to the nature of the block's
   content, the same encryption key will never be used to encrypt a
   different set of data and AAD, so a random IV is not necessary.

4.3.3.  Encoding

   Identities may be stored to file or optical (QR) code in binary
   format, or in base64url or base56check (Section 2.2) encoded text.
   Compatible clients MUST support at least one of these standard
   encodings.

   Identities stored in this standard format MUST include an 8 byte
   header identifying the encoding used for the remainder of the file,
   with a single exception: Identities exported to text using
   base56check encoding do not include a header.  Instead, they are
   validated by the encoded check characters.  The header itself is not
   encoded, but indicates that everything following it will be.

                     +-------------+----------------+
                     | Encoding    | Header (ASCII) |
                     +-------------+----------------+
                     | binary      | sqrldata       |
                     | base64url   | SQRLDATA       |
                     | base56check |                |
                     +-------------+----------------+

                  Table 4: Storage Encodings and Headers

4.4.  Identity Operations

   Identity creation, recovery, and rekeying are particularly vulnerable
   times for the SQRL identity, during which several Class A secrets may
   be exposed.  Special care is required to protect this sensitive key



Comley & Killian         Expires August 30, 2018               [Page 21]

Internet-Draft                    SQRL                     February 2018


   during these operations.  Clients SHOULD inform the user of the
   security implications and encourage the user not to perform these
   operations on a device that the user believes to be compromised.

4.4.1.  Identity Creation

   The SQRL identity is, in essence, just a long random number (the
   IUK).  In order to protect the new identity, both during creation and
   against future exploits, the client MUST use the highest quality
   entropy available to it while creating a new identity.  See
   Appendix C for recommendations on harvesting entropy.

   Creating an identity involves generating a random IUK and Rescue
   Code, deriving the IMK and ILK, and encrypting these keys.  In
   addition, the client MUST allow and encourage the user to store both
   the new identity and the Rescue Code in an offline format.  The
   following process is RECOMMENDED:

   1.  Begin harvesting entropy if the client does not do this
       continuously.

   2.  Prompt the user to name their new identity so that they can
       recognize it later.

   3.  Generate a random Rescue Code, and have the user store the Rescue
       Code offline.  Written or printed form is RECOMMENDED.  Encourage
       the user to securely store the Rescue Code in an offline format.
       The client MAY require the user to retype the Rescue Code to
       ensure that they have stored a copy.

   4.  Prompt the user for a password to protect the new identity.
       Clients SHOULD encourage the user to choose a strong password.

   5.  Generate a random IUK and store it in a newly constructed Type 2
       block (Section 4.3.2.2), encrypted with the newly generated
       Rescue Code.

   6.  Derive the IMK and ILK and store them in a newly constructed Type
       1 block (Section 4.3.2.1), encrypted with the user's new
       password.

   7.  Securely wipe any memory containing unencrypted keys or
       passwords.

   8.  Save the newly created blocks to local storage with the user
       chosen name.





Comley & Killian         Expires August 30, 2018               [Page 22]

Internet-Draft                    SQRL                     February 2018


   9.  Provide options for, and encourage the user to backup the new
       identity to an offline format.

4.4.2.  Importing / Exporting an Identity

   For compatibility, clients MUST support importing and exporting
   identities in at least one of these standard formats.  It is
   RECOMMENDED that clients support all of them.  Clients MAY offer
   additional formats as well.

   Binary File
      An identity in the standard format (Section 4.3), saved as a
      binary file with the "sqrldata" header.  The RECOMMENDED file
      extension is ".sqrl".

   QR Code


      *  TODO: Reference QR Code specification?

      *  TODO: Recommend Mode, Encoding, Error Correction, etc.

   Text
      An identity in the standard format (Section 4.3), encoded with
      base56check (Section 2.2), intended to be printed to paper for
      offline storage and manually entered by the user during import.

4.4.3.  Changing the User's Password

   Clients SHOULD allow the user to change their password at any time.
   The process is simple:

   1.  Using the user's current password, decrypt the Type 1 Block.
       Other block types are not affected by this operation.

   2.  Using the user's new password, re-encrypt the Type 1 Block.
       During encryption, EnScrypt MUST be called in Timer Mode, using
       the user's chosen "EnScrypt Seconds" option (Section 4.2).

   3.  Save the changes to non-volatile storage.

4.4.4.  Identity Recovery

   If the user has forgotten their password, or lost their identity
   file, identity recovery is required to reconstruct a usable identity.
   Depending on the situation, the client may be recovering from an
   existing identity file, or from an offline backup.  In either case,
   the procedure is the same:



Comley & Killian         Expires August 30, 2018               [Page 23]

Internet-Draft                    SQRL                     February 2018


   1.  Because the user's options are lost in this process, the client
       SHOULD give the user an opportunity to review the default options
       and make changes.

   2.  Prompt the user to enter their Rescue Code and new password.

   3.  Validate the Rescue Code by decrypting the Type 2 block and
       obtain the IUK.

   4.  Derive the IMK and ILK, and construct a new Type 1 block
       protected by the user's newly chosen password.

   5.  Securely wipe any memory containing unencrypted keys or
       passwords.

   6.  Save the recovered identity.

4.4.5.  Rekeying an Identity

   Rekeying an identity completely replaces the IUK with a new one.  It
   is only required when the user believes that their identity may have
   been compromised.  After rekeying, the client SHOULD encourage the
   user to visit and authenticate with any important sites to ensure
   that those sites update their identity association.  Until this is
   done, an attacker may still have full access to those sites.  To
   rekey an identity:

   1.  Prompt the user for their Rescue Code.

   2.  Using the Rescue Code, decrypt the Type 2 block to obtain the IUK
       (now a PIUK).

   3.  Follow the steps in Section 4.4.1 to create a new identity.

   4.  Before saving or exporting the new identity, a Type 3 block
       (Section 4.3.2.3) must be constructed:

       A.  If a Type 3 block already exists (rekeying has been performed
           in the past), the existing block must be decrypted and
           modified.  The "Edition" field is incremented, and the new
           PIUK is prepended to the existing PIUKs.  If the list now
           contains more than four PIUKs, the last (oldest) one is
           removed.

       B.  If a Type 3 block does not already exist, a new one is
           created.  Fill the "Edition" field with the number 1.  The
           encrypted section will contain only the new PIUK.




Comley & Killian         Expires August 30, 2018               [Page 24]

Internet-Draft                    SQRL                     February 2018


       C.  Encrypt the Type 3 block using the new IMK and ensure that it
           is saved / exported with the new identity.

5.  Client-Server Protocol

   TODO

5.1.  Initiation of SQRL Authentication

   TODO

5.1.1.  The SQRL Scheme

   TODO

5.1.2.  QR Codes (Out of Band)

   TODO

5.2.  The SQRL Realm (Domain)

   TODO

5.3.  Client to Server Requests

   TODO

5.3.1.  Protocol Version

   TODO

5.3.2.  Commands

   TODO

5.3.3.  Options

   TODO

5.3.4.  The server Value

   TODO

5.3.5.  The client Value

   TODO





Comley & Killian         Expires August 30, 2018               [Page 25]

Internet-Draft                    SQRL                     February 2018


5.3.6.  Client Keys

   TODO

5.3.7.  Client Signatures

   TODO

5.3.8.  Composing the Request

   TODO

5.4.  Server to Client Replies

   TODO

5.4.1.  Required Values

   TODO

5.4.2.  Optional Values

   TODO

5.4.3.  Additional Values

   TODO

5.4.4.  Composing the Reply

   TODO

6.  Client-Server Interactions

   TODO

6.1.  Same Device Authentication

   TODO

6.2.  Cross Device Authentication

   TODO








Comley & Killian         Expires August 30, 2018               [Page 26]

Internet-Draft                    SQRL                     February 2018


6.3.  Identity Association

   TODO

6.4.  Updating Identity Association

   TODO

6.5.  Disabling Site Login

   TODO

6.6.  Re-Enabling Site Login

   TODO

7.  IANA Considerations

   TODO

8.  Security Considerations

   As SQRL aims to protect a single identity that is ultimately used to
   authenticate a user everywhere, the security of this identity is
   paramount.  Further, users must face many of the same security issues
   as with traditional methods of authentication.

   It is important to consider the following attack goals:

   1.  Session hijacking

   2.  Site credential theft

   3.  Association of SQRL identity to site account

   4.  Master key theft

   5.  Breaking of pseudonymous nature of SQRL authentication
       (association of SQRL identities on various sites)

8.1.  Phishing

   One well-known attack mode is where the user is invited to click on a
   link appearing to go to a legitimate site, but is in reality directed
   to an attacker's server.

   One common method of this is a look-alike link.  For example, a user
   believing he is going to example.com is in reality going to



Comley & Killian         Expires August 30, 2018               [Page 27]

Internet-Draft                    SQRL                     February 2018


   examp1e.com (the lowercase "l" is replaced with a numeral "1").  A
   historical example is "tvvitter.com" (the letter "v" twice instead of
   a "w").

   Another method is to use a malformed URL to misdirect a user.  For
   example, this link:

   https://www.amazon.com@%67%72%63.%63%6f%6d/

   at first glance appears to be a link to Amazon, but in reality takes
   the user to grc.com.  In a real-world attack, the attacker would
   substitute the name of his phishing site and most users might be
   fooled entirely.

   The phishing site is generally set up to look and work exactly the
   way the real site works, at least up until the point where the
   attacker has stolen the intended data.

   Phishing attacks where the goal is to obtain authentication
   credentials are entirely foiled by SQRL.  Since SQRL uses the domain
   name as the basis for authentication, it will create completely
   different identity keys.  The SSPK the attacker gets will be a public
   key specifically for his attack site, useless to him for obtaining
   access to the real site.

   However, the attacker may have other goals.  If the attacker can
   successfully mimic a banking or e-commerce site, the user could be
   tricked into entering account data such as a credit card number.  The
   real domain name is displayed to the user in a font with unambiguous
   glyphs before any authentication occurs, giving him the opportunity
   to realize he is being fooled.

   Many phishing attacks are pass-through attacks, where the phishing
   site acts as an active Man-In-The-Middle.  It obtains the genuine
   page from the real site and passes it along to the user, receiving
   the user's responses and passing them back to the site.  In the case
   of same-device authentication (Section 6.1), the client will be
   warned of an IP mismatch, and CPS will redirect the browser to a safe
   page on the real site.  No such protections exist for cross-device
   authentication (Section 6.2), but this is generally used in the case
   of untrusted devices where the user will probably be typing in the
   domain name manually.

   The attacker can get around SQRL's protections with DNS spoofing,
   where the device's DNS addresses are altered, entries are added to
   the hosts file, or otherwise made to redirect a host name to an
   incorrect address, generally the phishing site controlled by the




Comley & Killian         Expires August 30, 2018               [Page 28]

Internet-Draft                    SQRL                     February 2018


   attacker.  In such a case, SQRL would be fooled (as would anything
   else on the compromised device).

   However, cross-device authentication would foil this, as the user
   would be using a smartphone or other trusted device that would be
   doing its own DNS lookup.  Local authentication should take place
   only on trusted devices.  DNS could only be spoofed on these devices
   using malware, but malware can compromise any security feature.

   A SQRL client MAY have an additional protection from such an attack
   in the form of an internal DNS resolver, bypassing the attacker's
   spoofing.  However, such a feature may not be desired on enterprise
   networks running their own internal DNS systems, so it should be an
   option the user can configure or turn off.

8.2.  Shoulder-Surfing

   Shoulder-surfing is when an attacker reads or scans the display,
   keyboard, and other components of the target's device directly,
   allowing the attacker to see sensitive information, including
   information entered into forms.

   In the context of SQRL, the danger is of an attacker scanning the QR
   code of a SQRL-enabled website.  With good timing, the attacker could
   fool the user into thinking he's logged in as himself when in reality
   he's authenticated to an account controlled by the attacker.  The
   attacker could then get anything the user enters into that web site,
   including credit card numbers and other sensitive information.

   However, in such a case the user's authentication would fail as the
   nut is no longer valid.  The SQRL client MUST deliver an error
   message to the user saying that the authentication has failed, and
   SHOULD advise the user of the dangers of continuing to use the web
   site, especially if the authentication has the appearance of having
   worked.

   Care should be taken when authenticating to a website in a public
   area, or any other place where others could see the QR code, or watch
   the user type the Master Password on the keyboard.  Keep in mind that
   these can be picked up using binoculars or seen on a CCTV camera.

   It is absolutely crucial that a new SQRL identity NOT be created, and
   an existing one NOT be rekeyed, in such an area.  Anyone who can
   resolve the screen and keyboard can get the Master Password, the full
   identity backup, AND the Rescue Code.






Comley & Killian         Expires August 30, 2018               [Page 29]

Internet-Draft                    SQRL                     February 2018


8.3.  Evil Router

   In this context, the router in consideration is the one connecting
   the user's LAN segment to the rest of the Internet.  Home routers
   have been shown to be lacking in security, and even a well-supported
   router must be updated when new firmware versions are released,
   something most users aren't aware of.

   It is also increasingly the case that users connect to Wi-Fi hotspots
   when travelling, relying on routers whose security they could not
   evaluate even if they knew to.  Moreover, an attacker on the LAN
   segment could engage in ARP spoofing to make the attacker's own
   device the default gateway for the segment, forwarding the packets on
   to the true router but establishing himself as a Man-In-The-Middle.

   Once an attacker gains control of the default gateway, he could
   engage in phishing and DNS spoofing attacks as described above.  More
   significantly, he could insert himself into the TLS handshake and
   commit any number of attacks designed to compromise the security of
   TLS.

   SQRL provides no means of defending the user against such an attack,
   however, at most the attacker will gain access to the specific login
   sessions the user makes while at that location.

8.4.  Server Compromise

   A server compromise can result in sensitive user data being obtained
   by the attacker without the user even logging in.

   In the case of SQRL there is less critical data for the attacker to
   get.  There are no passwords or other secrets sent to the server that
   have to be hashed and protected.  The attacker can only get the SSPK,
   SUK, and VUK, which are useless to him.

   If the attacker obtained write access, he could conceivably generate
   a new SUK and VUK based on his own IUK and take control of the
   account via the Identity Lock protocol.  However, if the attacker
   already has write access there would be little more to gain by doing
   so in most situations.

   If the attacker has gained access to more than one site, the SSPK
   would be different, meaning that the attacker could not correlate
   user data between websites (unless, of course, there was other
   identifying information in common such as an email address).

   All the same, once authenticated the user is subject to all of the
   harms that can occur regardless of the form of authentication.



Comley & Killian         Expires August 30, 2018               [Page 30]

Internet-Draft                    SQRL                     February 2018


8.5.  CPU Flooding

   CPU flooding is where the attacker is able to cause one or more
   processes to run that take up significant CPU time.  It also can
   happen without a malicious attacker, when a normal CPU-intensive
   process starts running in the background.

   With SQRL, this can be a vulnerability when running EnScrypt
   (Section 2.4) in Timer Mode.  After 5 seconds (by default), the timer
   runs out, and the resulting key is used to encrypt the identity and
   the number of iterations recorded.  If another process utilizes
   significant CPU clocks during this process, the total number of
   iterations will be lower than it would have, meaning that the Master
   Password has weaker protection against cracking.

8.6.  Evil Client

   An evil client is a maliciously-developed SQRL client.  It may take
   the form of its own client, or it may mimic an existing and trusted
   SQRL client.  It may enter the user's computer in the form of
   malware, hijacking the sqrl:// protocol as a new handler and
   attaching itself to the localhost:25519 port.  If artfully done, the
   user would have no clue that a substitution has been made.

   The consequences cannot be overstated.  The evil client would be able
   to gain the unencrypted IMK on its very first use, allowing the
   attacker to be able to hijack ANY account on ANY website where the
   user has authenticated using SQRL.

   Moreover, it could keep track of everywhere the user logs in and send
   to the attacker all of the user's accounts on banking, e-commerce,
   and other important websites.  And although a user can rekey his
   identity, he would first have to understand that his identity has
   been compromised.

   The absolute worst case scenario would be when a user uses an evil
   client to create or rekey his identity, which would give the attacker
   access to even the Rescue Code.  All other possible security concerns
   pale to this.

   SQRL mitigates this possibility by requiring (and advising) only that
   the user place his SQRL identity on trusted devices, using cross-
   device authentication on all other devices.  However, this only
   limits the attack surface.  In the past, fake versions of Firefox and
   other web browsers, fake Bitcoin wallets, and numerous others have
   been downloaded by users and even placed inside the trusted app
   stores for Android and iOS.  A malicious SQRL app, sadly, is not out
   of the question.



Comley & Killian         Expires August 30, 2018               [Page 31]

Internet-Draft                    SQRL                     February 2018


   This issue can be somewhat mitigated by requiring that SQRL apps be
   certified by trusted authorities.  The reference implementation from
   GRC not only checks the certificate on every update, but checks the
   fingerprint on the DigiCert root certificate as well to help ensure
   that there was no improper substitution.  However, the ultimate
   protection can only come from complete SQRL integration into web
   browsers and operating systems, which will refuse to let any other
   software hijack the sqrl:// protocol and eliminate the need for a
   localhost connection on port 25519.

9.  References

9.1.  Normative References

   [FIPS.180-4.2015]
              National Institute of Standards and Technology, "Secure
              Hash Standard", August 2015.

   [NIST.800-38D]
              Dworkin, M., "NIST Special Publication 800-38D:
              Recommendation for Block Cipher Modes of Operation:
              Galois/Counter Mode (GCM) and GMAC.", November 2007.

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997, <https://www.rfc-
              editor.org/info/rfc2104>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997, <https://www.rfc-
              editor.org/info/rfc2119>.

   [RFC2898]  Kaliski, B., "PKCS #5: Password-Based Cryptography
              Specification Version 2.0", RFC 2898,
              DOI 10.17487/RFC2898, September 2000, <https://www.rfc-
              editor.org/info/rfc2898>.

   [RFC3548]  Josefsson, S., Ed., "The Base16, Base32, and Base64 Data
              Encodings", RFC 3548, DOI 10.17487/RFC3548, July 2003,
              <https://www.rfc-editor.org/info/rfc3548>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.





Comley & Killian         Expires August 30, 2018               [Page 32]

Internet-Draft                    SQRL                     February 2018


   [RFC7914]  Percival, C. and S. Josefsson, "The scrypt Password-Based
              Key Derivation Function", RFC 7914, DOI 10.17487/RFC7914,
              August 2016, <https://www.rfc-editor.org/info/rfc7914>.

   [RFC8031]  Nir, Y. and S. Josefsson, "Curve25519 and Curve448 for the
              Internet Key Exchange Protocol Version 2 (IKEv2) Key
              Agreement", RFC 8031, DOI 10.17487/RFC8031, December 2016,
              <https://www.rfc-editor.org/info/rfc8031>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017, <https://www.rfc-
              editor.org/info/rfc8032>.

9.2.  Informative References

   [Klyubin]  Klyubin, A., "Some SecureRandom Thoughts", August 2013,
              <https://android-developers.googleblog.com/2013/08/some-
              securerandom-thoughts.html>.

   [RFC4868]  Kelly, S. and S. Frankel, "Using HMAC-SHA-256, HMAC-SHA-
              384, and HMAC-SHA-512 with IPsec", RFC 4868,
              DOI 10.17487/RFC4868, May 2007, <https://www.rfc-
              editor.org/info/rfc4868>.

   [Shamir]   Shamir, A., "How to share a secret",
              DOI 10.1145/359168.359176, November 1979.

Appendix A.  Recommendations and Best Practices

A.1.  For Clients

   TODO

A.2.  For Servers

   TODO

A.3.  For Users

   Disclaimer: None of this is intended to be any sort of legal advice,
   or indeed any guarantee that problems involving SQRL clients and
   identities will be minimized.  They are designed to apply to most
   SQRL users in most situations most of the time.  It should be up to
   each individual's discretion to determine whether or not particular
   recommendations make sense to their situation.





Comley & Killian         Expires August 30, 2018               [Page 33]

Internet-Draft                    SQRL                     February 2018


A.3.1.  Master Password

   Traditionally, security experts have advised having unique passwords
   for every resource.  The reason why is so that one resource being
   compromised will not threaten others.  However, in the case of a
   single SQRL identity copied to multiple devices, a compromise of any
   of these identities would give an attacker full access to all SQRL-
   enabled logins, so the user gains nothing from protecting his SQRL
   identity on different devices with different passwords.  But when
   users are asked to create different passwords, they generally pick
   weaker, formulaic passwords that are easier to remember.

   For this reason, it makes sense to have a single strong password
   protecting all copies of the user's SQRL identity.

A.3.2.  Identity Backup

   It is crucial that the user not lose his or her identity, as that
   would lock him out of any and all needed resources.  Keeping a secure
   backup is essential.

   SQRL clients do not distinguish between exporting and backing up an
   identity, whether done by file, QR code, or text.  But conceptually,
   exporting an identity is done with the intent to import it into
   another client in a timely manner.  Therefore, exporting generally
   includes the identity encrypted with the Master Password.

   Backups, on the other hand, are intended for longer-term storage.
   The encryption on them therefore needs to be more secure than perhaps
   will be the case with the user's Master Password, which may be
   forgotten in the interim anyway.  Therefore, when making a backup of
   an identity, it should be made without the Master Password,
   containing only a copy of the encrypted IUK from which the identity
   can be regenerated.  The user would therefore need the Rescue Code to
   restore the backup.

   Note that text backup MUST NOT be exported without the Master
   Password.

A.3.3.  Disaster Recovery

   A user putting together his Last Will and Testament will want the
   executor(s) of his estate to be able to easily access all important
   assets.  Since probate attorneys consider the security of all of this
   information to be paramount, it is recommended that they be given a
   hard copy of the SQRL client, exported without password, using the
   "data entry" method.  The Rescue Code must also be included.  The




Comley & Killian         Expires August 30, 2018               [Page 34]

Internet-Draft                    SQRL                     February 2018


   information must be updated whenever the user creates a new SQRL
   identity or rekeys an existing one.

   If the use of a probate attorney isn't desirable (e.g., the user
   lives in a country with no recognition of attorney-client privilege),
   SQRL's "data entry" export and the associated Rescue Code could be
   distributed through the person's heirs via Shamir's Secret Sharing.
   [Shamir]

Appendix B.  The Optional ShortPass Feature

   TODO

Appendix C.  Harvesting Entropy

   Secure cryptographic systems depend on the ability to create quality
   random numbers, and SQRL is no different in this regard.  SQRL's
   needs are meager compared to many other functions and protocols, but
   critical.

   The use of a pseudo-random function to generate random numbers is
   only as good as the entropy it is seeded with.  As RFC4086 points
   out, a hacker may find it easier to reproduce the environment a PRF
   was running in when it produced the secret quantities than to make
   blind guesses through the search space.  [RFC4086]

   Optimally, the numbers used for seeding cryptographic functions such
   as Curve25519 should be truly random, but what constitutes "truly
   random" is regarded as much philosophy as computer science.  However,
   a good working definition of "truly random" is one where the amount
   of entropy in a number is equal to its length; e.g., a 256-bit number
   that contains 256 bits of entropy.

   Unfortunately, determining the amount of entropy in an information
   stream is tricky at best.  But entropy is never reduced as more
   information is added; even weak sources of entropy, when added
   together, can produce sufficient entropy.  For that reason, none of
   the data collected during entropy harvesting should be discarded.

   The method recommended by SQRL is to harvest as much entropy as
   possible from as many uncorrelated sources as possible in the time
   available, and run the data stream through SHA-256 or SHA-512,
   depending on how much randomness is needed.  The Secure Hashing
   Algorithm should change half the bits of the output when just a
   single bit of the input is changed, so the entropy should be
   preserved up to the length of the resulting hash.  The technique,
   then, is to hash an amount of data where the entropy content almost




Comley & Killian         Expires August 30, 2018               [Page 35]

Internet-Draft                    SQRL                     February 2018


   certainly far exceeds 256 or 512 bits.  These amounts are fairly
   trivial.

   For more about entropy harvesting, see RFC4086.

C.1.  Entropy Sources

   Sources of entropy vary greatly depending on the hardware, operating
   system, and other aspects of the client device.

C.1.1.  Operating System

   All operating systems have a source of randomness available (e.g.,
   /dev/random on UNIX-like systems), but developers should think twice
   before relying solely on these.  Flaws and backdoors could result in
   a false sense of security.  For example, in 2013 a flaw in Android's
   SecureRandom function made wallets generated on those devices
   vulnerable to remote hacking and the theft of funds, even without
   access to the device.  See [Klyubin]

   Developers should also be advised that many of these use some of the
   same techniques described below, meaning that utilizing the same
   technique might not result in as much entropy as estimated.

C.1.2.  Hardware

   Hardware sources can be very effective at harvesting entropy, but
   care must be taken to make sure that they exist on a particular
   implementation, and that the hardware hasn't failed in some way.

   The system clock has traditionally been used as a source of
   randomness, although it must be considered that users are more likely
   to generate the random numbers at some times of the day than others.
   Subseconds provide the greatest entropy here.

   Some systems come with embedded hardware that produce noise
   specifically for the purpose of seeding PRFs.

   Wireless networking devices can be polled for signal strength and
   other data.

   Processor statistics can be a significant source, such as cache hits/
   misses and other low-level system counters, voltage, fan speed, and
   thermal data.

   Sound from a microphone could be a source of high-quality entropy in
   a typical room with air conditioning, fans, and other source of
   noise, as well as interference on the sound channel.  In such a case,



Comley & Killian         Expires August 30, 2018               [Page 36]

Internet-Draft                    SQRL                     February 2018


   a fraction of a second--less than two hundredths--would be
   sufficient, but as there is no guarantee longer periods should be
   considered.

   One or two frames from a camera can likewise be a source of high-
   entropy noise because of the sensor, which is especially the case if
   the SQRL client can set the camera's ISO to a high number.  Most cell
   phones in particular have cameras that generate sufficient noise in
   the low-order bits.  A single 640x480 frame would likely be
   sufficient for SQRL's purposes.  Care must be taken to ensure the
   client is getting the raw camera data, not compressed data which may
   have much of the noise removed.

   Free bytes of memory and storage space can vary quite a bit, adding a
   not insignificant amount of entropy.

   Network statistics, such as packet arrival time, can be effective,
   but only if it can be ensured that these are not subject to
   manipulation.

C.1.3.  User

   The user can provide a good measure of entropy, either directly by
   the client engaging the user, or indirectly.

   Examining mouse movements or keyboard strokes can be a source of
   entropy, although how much is a matter of some debate.

   Accelerometer data on cell phones and other such devices can pick up
   minute movements of the user's hand, even if the user is trying to
   hold it steady.

Authors' Addresses

   Adam Comley

   Email: adam@novators.net


   Shane Killian

   Email: shane@shanekillian.org









Comley & Killian         Expires August 30, 2018               [Page 37]
