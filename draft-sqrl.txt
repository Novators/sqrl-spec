



Internet Engineering Task Force                           A. Comley, Ed.
Internet-Draft                                         February 17, 2018
Intended status: Informational
Expires: August 21, 2018


   Secure Quick Reliable Login (SQRL), an Authentication and Identity
                          Management Framework
                           draft-sqrl-working

Abstract

   Secure Quick Reliable Login (SQRL) is an authentication method and
   identity management framework.  It enables a user to create and
   manage a single, pseudonymous lifetime identity.  That identity will
   allow the user to securely authenticate with any SQRL enabled server
   without relying on a third party or disclosing personally
   identifiable information.

   SQRL's identity management framework gives the user complete control
   over their online identity, including provisions for recovering from
   the loss of their identity file or password and recovering from
   potential security breaches.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on August 21, 2018.

Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents



Comley                   Expires August 21, 2018                [Page 1]

Internet-Draft                    SQRL                     February 2018


   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   5
     1.2.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   5
   2.  Algorithms  . . . . . . . . . . . . . . . . . . . . . . . . .   5
     2.1.  Standard Algorithms . . . . . . . . . . . . . . . . . . .   5
     2.2.  base56check . . . . . . . . . . . . . . . . . . . . . . .   6
       2.2.1.  Encoding  . . . . . . . . . . . . . . . . . . . . . .   6
       2.2.2.  Validation  . . . . . . . . . . . . . . . . . . . . .   7
       2.2.3.  Decoding  . . . . . . . . . . . . . . . . . . . . . .   8
     2.3.  EnHash  . . . . . . . . . . . . . . . . . . . . . . . . .   8
     2.4.  EnScrypt  . . . . . . . . . . . . . . . . . . . . . . . .   8
   3.  Cryptographic Keys, Secrets, and Passwords  . . . . . . . . .   9
     3.1.  Class A Secrets . . . . . . . . . . . . . . . . . . . . .  10
       3.1.1.  Identity Unlock Key (IUK) . . . . . . . . . . . . . .  10
       3.1.2.  Unlock Request Signing Key (URSK) . . . . . . . . . .  10
       3.1.3.  Rescue Code (RC)  . . . . . . . . . . . . . . . . . .  10
       3.1.4.  Password Derived Keys . . . . . . . . . . . . . . . .  11
     3.2.  Class B Secrets . . . . . . . . . . . . . . . . . . . . .  11
       3.2.1.  Previous Identity Unlock Key (PIUK) . . . . . . . . .  12
       3.2.2.  Identity Master Key (IMK) . . . . . . . . . . . . . .  12
       3.2.3.  Identity Lock Key (ILK) . . . . . . . . . . . . . . .  12
       3.2.4.  Site Specific Secret Key (SSSK) . . . . . . . . . . .  12
       3.2.5.  Random Lock Key (RLK) . . . . . . . . . . . . . . . .  12
     3.3.  Class C (Public) Keys . . . . . . . . . . . . . . . . . .  12
       3.3.1.  Site Specific Public Key (SSPK) . . . . . . . . . . .  12
       3.3.2.  Server Unlock Key (SUK) . . . . . . . . . . . . . . .  13
       3.3.3.  Verify Unlock Key (VUK) . . . . . . . . . . . . . . .  13
   4.  Identity Management . . . . . . . . . . . . . . . . . . . . .  13
     4.1.  Identity Lifecycle  . . . . . . . . . . . . . . . . . . .  13
     4.2.  Identity Creation . . . . . . . . . . . . . . . . . . . .  13
     4.3.  User Options  . . . . . . . . . . . . . . . . . . . . . .  13
     4.4.  Identity Storage  . . . . . . . . . . . . . . . . . . . .  14
       4.4.1.  Encoding  . . . . . . . . . . . . . . . . . . . . . .  15
       4.4.2.  Storage Blocks  . . . . . . . . . . . . . . . . . . .  15
       4.4.3.  Predefined Block Types  . . . . . . . . . . . . . . .  16
     4.5.  Importing / Exporting an Identity . . . . . . . . . . . .  18
       4.5.1.  Binary File . . . . . . . . . . . . . . . . . . . . .  18
       4.5.2.  Printed QR Code . . . . . . . . . . . . . . . . . . .  18



Comley                   Expires August 21, 2018                [Page 2]

Internet-Draft                    SQRL                     February 2018


       4.5.3.  Printed Text  . . . . . . . . . . . . . . . . . . . .  18
     4.6.  Changing the User's Password  . . . . . . . . . . . . . .  18
     4.7.  Identity Recovery . . . . . . . . . . . . . . . . . . . .  18
     4.8.  Re-Keying and Identity  . . . . . . . . . . . . . . . . .  18
   5.  Client-Server Protocol  . . . . . . . . . . . . . . . . . . .  18
     5.1.  Initiation of SQRL Authentication . . . . . . . . . . . .  18
       5.1.1.  The SQRL Scheme . . . . . . . . . . . . . . . . . . .  18
       5.1.2.  QR Codes (Out of Band)  . . . . . . . . . . . . . . .  18
     5.2.  The SQRL Realm (Domain) . . . . . . . . . . . . . . . . .  19
     5.3.  Client to Server Requests . . . . . . . . . . . . . . . .  19
       5.3.1.  Protocol Version  . . . . . . . . . . . . . . . . . .  19
       5.3.2.  Commands  . . . . . . . . . . . . . . . . . . . . . .  19
       5.3.3.  Options . . . . . . . . . . . . . . . . . . . . . . .  19
       5.3.4.  The server Value  . . . . . . . . . . . . . . . . . .  19
       5.3.5.  The client Value  . . . . . . . . . . . . . . . . . .  19
       5.3.6.  Client Keys . . . . . . . . . . . . . . . . . . . . .  19
       5.3.7.  Client Signatures . . . . . . . . . . . . . . . . . .  19
       5.3.8.  Composing the Request . . . . . . . . . . . . . . . .  19
     5.4.  Server to Client Replies  . . . . . . . . . . . . . . . .  19
       5.4.1.  Required Values . . . . . . . . . . . . . . . . . . .  20
       5.4.2.  Optional Values . . . . . . . . . . . . . . . . . . .  20
       5.4.3.  Additional Values . . . . . . . . . . . . . . . . . .  20
       5.4.4.  Composing the Reply . . . . . . . . . . . . . . . . .  20
   6.  Client-Server Interactions  . . . . . . . . . . . . . . . . .  20
     6.1.  Same Device Authentication  . . . . . . . . . . . . . . .  20
     6.2.  Cross Device Authentication . . . . . . . . . . . . . . .  20
     6.3.  Identity Association  . . . . . . . . . . . . . . . . . .  20
     6.4.  Updating Identity Association . . . . . . . . . . . . . .  20
     6.5.  Disabling Site Login  . . . . . . . . . . . . . . . . . .  20
     6.6.  Re-Enabling Site Login  . . . . . . . . . . . . . . . . .  20
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  21
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  21
     8.1.  Phishing  . . . . . . . . . . . . . . . . . . . . . . . .  21
     8.2.  Shoulder-Surfing  . . . . . . . . . . . . . . . . . . . .  23
     8.3.  Evil Router . . . . . . . . . . . . . . . . . . . . . . .  23
     8.4.  Server Compromise . . . . . . . . . . . . . . . . . . . .  24
     8.5.  CPU Flooding  . . . . . . . . . . . . . . . . . . . . . .  24
     8.6.  Evil Client . . . . . . . . . . . . . . . . . . . . . . .  24
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  25
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  25
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  26
   Appendix A.  SQRL Client Best Practices . . . . . . . . . . . . .  27
   Appendix B.  SQRL Server Best Practices . . . . . . . . . . . . .  27
   Appendix C.  Harvesting Entropy . . . . . . . . . . . . . . . . .  27
     C.1.  Entropy Sources . . . . . . . . . . . . . . . . . . . . .  28
       C.1.1.  Operating System  . . . . . . . . . . . . . . . . . .  28
       C.1.2.  Hardware  . . . . . . . . . . . . . . . . . . . . . .  28
       C.1.3.  User  . . . . . . . . . . . . . . . . . . . . . . . .  29



Comley                   Expires August 21, 2018                [Page 3]

Internet-Draft                    SQRL                     February 2018


   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  29

1.  Introduction

   Secure Quick Reliable Login (SQRL) is an authentication method and
   identity management framework with the following features:

   Secure
      Through a series of cryptographic signatures, the user can prove
      their identity without disclosing any information that would allow
      that identity to be compromised or their account hacked.

   Global Password
      The user only has to remember a single password, which is used to
      locally decrypt their identity during SQRL authentication.  Since
      the user no longer has to remember a unique password for each
      site, this one global password can be very strong.  This strong
      password combined with strong encryption makes it infeasible for
      even a state level actor to compromise the user's identity.  (SQRL
      apps can alternately use other methods of protection such as
      biometrics when available on the host device.)

   Anonymous
      SQRL authentication is pseudonymous, in that it only provides a
      secure, site-specific token to the server.  This token cannot be
      directly linked to a user's account at any other server, and
      provides no personally identifiable information.

   No Third Party
      The user's identity cannot be compromised by a security breach at
      a third party authentication provider, protecting it from both
      hackers and overreaching authorities.

   User Controlled, Lifetime Identity
      SQRL provides an identity management framework which allows the
      user to maintain complete control of their identity.  Even in the
      event that their password is compromised, the user retains the
      ability to retake control of their identity and lock the attacker
      out.  Automated rekeying means that the user can maintain a single
      SQRL identity indefinately, even after a compromise

   Offline Identity Backup
      Since SQRL identities are intended to last a lifetime, and there
      is no third party that can help the user recover their identity if
      they forget their password, SQRL includes an offline backup
      mechanism.  The user can print out or write down their encrypted
      identity, along with a secure Rescue Code, that will allow the
      user to recover from a forgotten password.



Comley                   Expires August 21, 2018                [Page 4]

Internet-Draft                    SQRL                     February 2018


   Out Of Band Authentication Option
      With SQRL, the user can safely authenticate a session on public or
      potentially compromised systems by scanning a QR code on a trusted
      mobile device containing their SQRL identity, without the need to
      expose that identity to the public system.

1.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

1.2.  Definitions

   TODO

2.  Algorithms

   TODO

2.1.  Standard Algorithms

   The following standard algorithms are used in this document:

   o  AES-GCM [NIST.800-38D]

   o  base64url: URL safe base64 encoding, as defined in Section 4 of
      [RFC3548], without padding.

   o  Curve25519 [RFC8031]

   o  Ed25519 [RFC8032]

   o  HMAC [RFC2104]

   o  HMAC-SHA256 [RFC4868]

   o  PBKDF2 [RFC2898]

   o  scrypt [RFC7914]

   o  SHA-256 [FIPS.180-4.2015]

   o  urlencode: Percent-Encoding as defined in Section 2.1 of
      [RFC3986].






Comley                   Expires August 21, 2018                [Page 5]

Internet-Draft                    SQRL                     February 2018


2.2.  base56check

   base56check encoding allows the backup of SQRL identities to a
   textual form.  It:

   o  Accepts an arbitrarily sized payload.

   o  Uses a set of 56 alphanumeric symbols chosen to be easily
      distinguishable in any font.

   o  Ignores invalid characters and white space to allow readable
      formatting.

   o  Designed to be printed 20 characters per line, in 5 space
      separated groups of 4 characters for readability.

   o  Includes a check character at the end of each line to catch errors
      while the user is typing with 98.2% accuracy.

   The chosen alphabet is:

   23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz

2.2.1.  Encoding

   To encode a series of bytes to base56check, treat the source bytes as
   a single, large, little-endian number and convert using the normal
   mathematical steps:

   1.  Calculate BASE_LENGTH: ceil( SOURCE_LENGTH * 8.0 / log2(56))

   2.  Divide SOURCE by 56 to yield SOURCE and REMAINDER.

   3.  Append the character in ALPHABET at position REMAINDER to the
       BASE string.

   4.  Repeat from step 1, until SOURCE is zero.

   5.  Append '2' (character in ALPHABET at position 0) to BASE until
       BASE is BASE_LENGTH bytes long.

   Now, with our converted BASE string, we can calculate the check
   digits and produce the final output.

   6.  Split BASE into 19 character CHUNKS (the final chunk may be
       smaller).

   7.  For each CHUNK:



Comley                   Expires August 21, 2018                [Page 6]

Internet-Draft                    SQRL                     February 2018


       A.  Append a single byte zero-based CHUNK-NUMBER to the CHUNK.

       B.  Perform a SHA-256 hash on the CHUNK, yielding HASH.

       C.  Treating HASH as a single little-endian number, divide HASH
           by 56 to obtain REMAINDER.

       D.  Replace the last character in CHUNK with the character in
           ALPHABET at position REMAINDER.

       E.  Append the CHUNK to OUTPUT.

   OUTPUT can then be formatted as desired.  The RECOMMENDED formatting
   is 20 characters per line in space-separated groups of 4 characters
   each.  This format is easy for humans to read and type, and allows
   error checking for each line of input.

2.2.2.  Validation

   base56check is designed to provide periodic error checking and
   feedback to the user as they are typing.  To perform this validation:

   1.  Remove any characters from INPUT that are invalid (not included
       in ALPHABET).

   2.  Split INPUT into 20 character CHUNKS (the final chunk may be
       smaller).

   3.  For each CHUNK:

       A.  Store the last character from CHUNK as CHECK.

       B.  Replace the last character in CHUNK with a single byte zero-
           based CHUNK-NUMBER.

       C.  Perform a SHA-256 hash on the CHUNK, yielding HASH.

       D.  Treating HASH as a single little-endian number, divide HASH
           by 56 to obtain REMAINDER.

       E.  Compare CHECK with the character from ALPHABET at position
           REMAINDER.

       F.  If comparison passes (is equal), continue.  Otherwise, there
           is an error in this CHUNK.






Comley                   Expires August 21, 2018                [Page 7]

Internet-Draft                    SQRL                     February 2018


2.2.3.  Decoding

   Decoding base56check is similarly straight-forward:

   1.  Start with an empty BASE string and an zero OUTPUT buffer, to be
       treated as a single, large, little-endian number.

   2.  Perform the base56check validation as described above, appending
       all but the last character of each validated CHUNK to the BASE
       string.

   3.  If any chunk fails validation, abort.

   4.  For each CHARACTER in BASE, from right to left:

       A.  Multiply OUTPUT by 56.

       B.  Lookup the INDEX of CHARACTER in ALPHABET.

       C.  Add INDEX to OUTPUT.

2.3.  EnHash

   EnHash is an iterated hash used to derive a 256 bit key from another
   256 bit key.  It is performed by chaining 16 iterations of SHA-256,
   with each iteration's output XORed to produce the final output as
   follows:

   function EnHash ( input := 32 byte key )
   {
     output := 32 byte buffer;

     set output to all NULL (0) bytes;

     repeat {
       input = SHA256( input );
       output = output XOR input;
     } 16 times;

     return output;
   }

2.4.  EnScrypt

   EnScrypt is an iterative construct based on the scrypt password based
   key derivation function.  It hardens scrypt by allowing for extended
   processing time.  The following parameters are used for the scrypt
   function:



Comley                   Expires August 21, 2018                [Page 8]

Internet-Draft                    SQRL                     February 2018


                     +-------+------------+-----+---+
                     | dkLen | N          | r   | p |
                     +-------+------------+-----+---+
                     | 32    | 512 (1<<9) | 256 | 1 |
                     +-------+------------+-----+---+

                        Table 1: scrypt parameters

   In this document, we may refer to an additional parameter, "n-factor"
   or just "n".  This is simply a shorthand way of storing the N
   parameter.  N is derived from n as follows:

   N = (1 << n);

   Enscrypt is performed by calling scrypt in multiple rounds, with each
   successive round accepting the previous round's output as its salt.
   The final output is the XOR of each round's scrypt result.

    +---------+-------------------------------+-----------------------+
    | Round # | let salt[n] =                 | let out =             |
    +---------+-------------------------------+-----------------------+
    | 1       | scrypt( password, salt )      | salt[1]               |
    | 2       | scrypt( password, salt[1] )   | salt[1] XOR salt[2]   |
    | n       | scrypt( password, salt[n-1] ) | salt[n-1] XOR salt[n] |
    +---------+-------------------------------+-----------------------+

                         Table 2: EnScrypt Rounds

   EnScrypt can operate in two different modes, the only difference
   being when the calculation is stopped.

   Counter Mode:
      Stops after a predefined number of iterations.

   Timer Mode:
      Stops after a desired amount of time has passed (5 seconds by
      default).

   Timer Mode is used when creating an encryption key from a password.
   Once the key is derived and the identity encrypted, the resulting
   number of iterations is saved with the identity file.  Counter Mode
   is used to recreate this key and decrypt the identity.

3.  Cryptographic Keys, Secrets, and Passwords

   SQRL uses a wide variety of secrets in various operations.





Comley                   Expires August 21, 2018                [Page 9]

Internet-Draft                    SQRL                     February 2018


3.1.  Class A Secrets

   Class A secrets are absolutely critical to protecting a user's
   identity.  A compromised Class A secret may result in the user's
   complete loss of control of the identity, with no recourse available.
   Due to their highly sensitive nature, the following precautions are
   REQUIRED when dealing with Class A secrets:

   o  The secret MUST be generated using the highest quality entropy
      source available to the client.  See Appendix C for
      recommendations.

   o  The client MUST prevent the secret from being written to non-
      volatile memory in plaintext form, including being swapped to
      disk, by any means possible.

   o  The plaintext secret MUST be securely wiped from RAM as soon as it
      is no longer needed.

   o  If the secret is to be stored, it MUST be stored in an offline
      format (printed), OR encrypted using a Class A key.

   o  The secret SHOULD NOT be transmitted over the network in any form,
      and MUST NOT be transmitted unencrypted.

3.1.1.  Identity Unlock Key (IUK)

   IUK = RandomBytes( 32 );

   The IUK is a Class A 256 bit high entropy random number that
   represents a user's identity.  All other identifying keys are derived
   from this one.  After identity creation, this key is only used in
   emergency situations, such as re-keying an identity in the event of a
   possible compromise.

3.1.2.  Unlock Request Signing Key (URSK)

   URSK = curve25519_key_agreement( SUK, curve25519_private_key( IUK ));

   Used by the client to update the identity association on a server,
   the URSK is derived from the SUK and IUK.

3.1.3.  Rescue Code (RC)

   The Rescue Code is a Class A, computer generated, high entropy
   passcode consisting of 24 numeric digits.  The client SHOULD
   encourage the user to store the Rescue Code in an offline format
   (printed or written).



Comley                   Expires August 21, 2018               [Page 10]

Internet-Draft                    SQRL                     February 2018


3.1.4.  Password Derived Keys

   Several keys are generated from user input.  Both the user supplied
   passwords and the derived keys are to be treated as Class A secrets.
   Since these are expected to be low entropy, they must be processed
   through EnScrypt (Section 2.4).  When generating derived keys,
   EnScrypt MUST be used in timer mode with a minimum duration of 1
   second.  The table below lists RECOMMENDED durations for EnScrypt key
   generation:

       +----------------------------+--------------+---------------+
       | Key                        | Abbreviation | EnScrypt Time |
       +----------------------------+--------------+---------------+
       | Password Derived Key       | PWDK         | 5 seconds     |
       | Short Password Derived Key | SPDK         | 1 second      |
       | Rescue Code Derived Key    | RCDK         | 60 seconds    |
       +----------------------------+--------------+---------------+

       Table 3: Password Derived Keys and Recommended EnScrypt Times

   Clients MAY allow the user to specify the EnScrypt time for the PWDK,
   as long as that timer is at least 1 second.  The RCDK is used so
   rarely, and is so important to protect, that 60 seconds should not
   cause an undue burden on the user.

   When re-generating derived keys, EnScrypt is used in counter mode
   with the iteration count from the original generation operation.

3.2.  Class B Secrets

   Class B secrets are used often, and have less strict security
   requirements.  A compromised Class B secret may result in an attacker
   temporarily gaining the ability to impersonate the user to any
   server, but the user can regain control of their identity by rekeying
   followed by authenticating with each affected server.  The following
   precautions are REQUIRED when dealing with Class B secrets:

   o  The client MUST prevent the secret from being written to non-
      volatile memory in plaintext form, including being swapped to
      disk, by any means possible.

   o  The plaintext secret MUST be securely wiped from RAM as soon as it
      is no longer needed.

   o  If the secret is to be stored, it MUST be stored in an encrypted
      form.





Comley                   Expires August 21, 2018               [Page 11]

Internet-Draft                    SQRL                     February 2018


   o  The secret SHOULD NOT be transmitted over the network in any form,
      and MUST NOT be transmitted unencrypted.

3.2.1.  Previous Identity Unlock Key (PIUK)

   A PIUK is an IUK that is no longer in active use.  It has been
   replaced by a newly generated IUK, and requires less strict
   protection.

3.2.2.  Identity Master Key (IMK)

   IMK = EnHash( IUK );

   This Class B ) key acts as a proxy for the IUK during normal SQRL
   operation.  It is used to generate the unique keys that each site
   associates with the user.  The IMK is derived from the IUK using the
   EnHash (Section 2.3) function.

3.2.3.  Identity Lock Key (ILK)

   ILK = curve25519_public_key( curve25519_private_key( IUK ));

   The (modified) IUK and ILK together form a Curve25519 key pair.

3.2.4.  Site Specific Secret Key (SSSK)

   SSSK = HMAC-SHA256( IMK, Realm );

   The Site Specific Secret Key is generated from the IMK and the Realm
   (Section 5.2).

3.2.5.  Random Lock Key (RLK)

   RLK = curve25519_private_key( RandomBytes( 32 ));

   The RLK is generated randomly when the client associates with a new
   server.

3.3.  Class C (Public) Keys

   Class C keys are not required to be kept secret.

3.3.1.  Site Specific Public Key (SSPK)

   SSPK = ed25519_public_key( SSSK );

   The Site Specific Public Key (SSPK) is the public counterpart to the
   SSSK.  It serves as the user's pseudonymous identity on the site.



Comley                   Expires August 21, 2018               [Page 12]

Internet-Draft                    SQRL                     February 2018


3.3.2.  Server Unlock Key (SUK)

   SUK = curve25519_public_key( RLK );

   Created during identity association, the SUK is the public
   counterpart of the RLK.

3.3.3.  Verify Unlock Key (VUK)

   VUK = ed25519_public_key( curve25519_key_agreement( ILK, RLK ));

   Generated during identity association, and stored only on the server,
   the VUK is the public key used to verify the client's URSK.

4.  Identity Management

4.1.  Identity Lifecycle

   TODO

4.2.  Identity Creation

   TODO

4.3.  User Options

   Several user options are available which will affect the operation of
   compatible SQRL clients:

   ShortPass Length:
      The number of characters from the user's password to use as the
      ShortPass.  Clients that implement ShortPass MUST honor the user's
      choice here.  Valid values are 0 to 255.  A value of 0 disables
      the ShortPass feature.

   EnScrypt Seconds:
      The number of seconds to run EnScrypt when deriving the PWDK.  The
      RECOMMENDED default is 5 seconds.  The REQUIRED minimum is 1
      second.

   Idle Timeout:
      If the client implements ShortPass or holds the user's password or
      keys in memory in any form, and the 0x0080 option flag is set, it
      MUST securely erase that memory after this many minutes of system
      idle time.  Valid values are 1-65535.

   Option Flags:
      The following binary flags turn on or off various user options:



Comley                   Expires August 21, 2018               [Page 13]

Internet-Draft                    SQRL                     February 2018


   +--------+----------------------------------------------------------+
   | Flag   | Description                                              |
   +--------+----------------------------------------------------------+
   | 0x0001 | Check for updates:  Gives the client permission to       |
   |        | periodically check for updates.                          |
   | 0x0002 | Update Automatically:  Requests that the client          |
   |        | automatically update itself when a new version is        |
   |        | available.                                               |
   | 0x0004 | Request SQRL only:  Requests that servers disable other  |
   |        | means of authentication and only allow SQRL.             |
   | 0x0008 | Request no bypass:  Requests that servers not allow non- |
   |        | SQRL account recovery options.                           |
   | 0x0010 | Warn of possible MITM attack: The client will warn the   |
   |        | user if their IP doesn't match the server's              |
   |        | expectations.                                            |
   | 0x0020 | Clear ShortPass when screen blanks: The client will      |
   |        | securely erase any ShortPass information when the screen |
   |        | saver is activated or the system is going to suspend /   |
   |        | sleep modes.                                             |
   | 0x0040 | Clear ShortPass when changing users: The client will     |
   |        | securely erase any ShortPass information when the        |
   |        | system's active user changes.                            |
   | 0x0080 | Clear ShortPass after idle timer: The client will        |
   |        | securely erase any ShortPass information after the       |
   |        | system has been idle for an amount of time specified in  |
   |        | the "Idle Timeout" option.                               |
   | 0x0100 | Warn of non-CPS authentication: The client will warn the |
   |        | user before a non-CPS authentication is attempted.  This |
   |        | flag MUST default to on.                                 |
   +--------+----------------------------------------------------------+

                             User Option Flags

4.4.  Identity Storage

   Because SQRL identities are intended to last the user's lifetime, the
   user needs to be able to move his identity between clients.  Every
   SQRL client MUST be able to import from and export identities to this
   standard format, regardless of how they store the identity
   internally.

   Because identities should be backed up offline (to printed paper),
   the storage format must be compact enough to reliably fit in a
   printed QR code, and short enough to not cause undue burden if the
   user has to type it in by hand.

   Values stored in standard SQRL storage format MUST follow these
   rules:



Comley                   Expires August 21, 2018               [Page 14]

Internet-Draft                    SQRL                     February 2018


   o  All numeric values are unsigned.

   o  Multibyte numeric values are stored in little endian byte order,
      with the least significant byte first.

   o  String values are stored in natural order, first byte first.

4.4.1.  Encoding

   Identities may be stored to file or optical (QR) code in binary
   format, or in base64url or base56check (Section 2.2) encoded text.
   Compatible clients MUST support at least one of these standard
   encodings.

   Identities stored in this standard format MUST include an 8 byte
   header identifying the encoding used for the remainder of the file,
   with a single exception: Identities exported to text using
   base56check encoding do not include a header.  Instead, they are
   validated by the encoded check characters.  The header itself is not
   encoded, but indicates that everything following it will be.

                     +-------------+----------------+
                     | Encoding    | Header (ASCII) |
                     +-------------+----------------+
                     | binary      | sqrldata       |
                     | base64url   | SQRLDATA       |
                     | base56check |                |
                     +-------------+----------------+

                  Table 4: Storage Encodings and Headers

4.4.2.  Storage Blocks

   A stored SQRL identity is composed of any number of blocks.  Each
   block begins with a four byte header identifying the total length of
   the block and the type of data stored in the block.

              +-----------------------------+--------------+
              | Field                       | Size (bytes) |
              +-----------------------------+--------------+
              | block length in bytes (n+4) | 2            |
              | block type                  | 2            |
              | block data                  | n            |
              +-----------------------------+--------------+

                       Table 5: Storage Block Format





Comley                   Expires August 21, 2018               [Page 15]

Internet-Draft                    SQRL                     February 2018


   Standard block types are defined in the next section.  Clients MAY
   add their own block types to store additional information, but SHOULD
   consider types 0-255 as reserved for future official block types.
   Any client reading an identity that encouters a block type unknown to
   that client MUST simply ignore that block.

4.4.3.  Predefined Block Types

4.4.3.1.  Block Type 1: Working Identity

   The type 1 block contains the user's encrypted IMK and ILK, as well
   as user defined options.  The user options are in plain text, but
   MUST be regarded as untrusted until authenticated through AES-GCM.
   Type 1 blocks are encrypted with AES-GCM using the PWDK.  The type 1
   block is formatted as follows:

              +--------------------------+---------+-------+
              | Field                    | Default | Bytes |
              +--------------------------+---------+-------+
              | Block Length             | 125     |     2 |
              | Block Type               | 1       |     2 |
              | AAD Length               | 45      |     2 |
              | AES-GCM IV               |         |    12 |
              | EnScrypt Salt            |         |    16 |
              | EnScrypt n-factor        | 9       |     1 |
              | EnScrypt Iteration Count |         |     4 |
              | User Option Flags        | 0x01F3  |     2 |
              | ShortPass Length         | 4       |     1 |
              | EnScrypt Seconds         | 5       |     1 |
              | Idle Timeout (minutes)   | 15      |     2 |
              | Encrypted IMK            |         |    32 |
              | Encrypted ILK            |         |    32 |
              | AES-GCM Verification Tag |         |    16 |
              +--------------------------+---------+-------+

                               Type 1 Block

   Constructing a type 1 block is relatively straight-forward:

   1.  Allocate a 125 byte buffer.

   2.  Populate the default values (or user chosen options).

   3.  Generate a random 12 byte initialization vector (IV) and store it
       in the buffer.

   4.  Generate a random 16 byte salt and store it in the buffer.




Comley                   Expires August 21, 2018               [Page 16]

Internet-Draft                    SQRL                     February 2018


   5.  Use the generated salt, the user's password, and the user's
       chosen EnScrypt Seconds value to generate the PWDK and Iteration
       Count.

   6.  Populate the Iteration Count in the buffer.

   7.  AES-GCM encrypt the IMK and ILK (64 bytes total) using the first
       "AAD Length" bytes of the buffer as AAD, the IV, the PWDK.

   8.  Populate the ciphertext result and verification tag from AES-GCM.

   9.  Securely wipe the plaintext keys, encryption key, and password
       from memory if they are no longer needed.

   If the client is updating a type 1 block, and the user's password
   hasn't changed, clients SHOULD use the original salt and iteration
   count to re-encrypt the block.

4.4.3.2.  Block Type 2: Rescue Identity

   The type 2 block contains a single key, the IUK, along with it's
   encryption parameters.  It is encrypted with AES-GCM using the RCDK.

              +--------------------------+---------+-------+
              | Field                    | Default | Bytes |
              +--------------------------+---------+-------+
              | Block Length             | 73      | 2     |
              | Block Type               | 2       | 2     |
              | EnScrypt Salt            |         | 16    |
              | EnScrypt n-factor        | 9       | 1     |
              | EnScrypt Iteration Count |         | 4     |
              | Encrypted IUK            |         | 32    |
              | AES-GCM Verification Tag |         | 16    |
              +--------------------------+---------+-------+

                               Type 2 Block

   The type 2 block is constructed the same way as the type 1, with the
   following exceptions:

   o  To save space in textual exports, we implicitly use a 12 byte, all
      zero Initialization Vector for AES-GCM.  This means that the type
      2 block MUST NOT be re-encrypted with different parameters.  This
      block MUST NOT be changed after identity creation.  It can only be
      replaced by rekeying.

   o  The RCDK is used in place of the PWDK.




Comley                   Expires August 21, 2018               [Page 17]

Internet-Draft                    SQRL                     February 2018


4.4.3.3.  Block Type 3: Previous Identities

4.5.  Importing / Exporting an Identity

   TODO

4.5.1.  Binary File

   TODO

4.5.2.  Printed QR Code

   TODO

4.5.3.  Printed Text

   TODO

4.6.  Changing the User's Password

   TODO

4.7.  Identity Recovery

   TODO

4.8.  Re-Keying and Identity

   TODO

5.  Client-Server Protocol

   TODO

5.1.  Initiation of SQRL Authentication

   TODO

5.1.1.  The SQRL Scheme

   TODO

5.1.2.  QR Codes (Out of Band)

   TODO






Comley                   Expires August 21, 2018               [Page 18]

Internet-Draft                    SQRL                     February 2018


5.2.  The SQRL Realm (Domain)

   TODO

5.3.  Client to Server Requests

   TODO

5.3.1.  Protocol Version

   TODO

5.3.2.  Commands

   TODO

5.3.3.  Options

   TODO

5.3.4.  The server Value

   TODO

5.3.5.  The client Value

   TODO

5.3.6.  Client Keys

   TODO

5.3.7.  Client Signatures

   TODO

5.3.8.  Composing the Request

   TODO

5.4.  Server to Client Replies

   TODO








Comley                   Expires August 21, 2018               [Page 19]

Internet-Draft                    SQRL                     February 2018


5.4.1.  Required Values

   TODO

5.4.2.  Optional Values

   TODO

5.4.3.  Additional Values

   TODO

5.4.4.  Composing the Reply

   TODO

6.  Client-Server Interactions

   TODO

6.1.  Same Device Authentication

   TODO

6.2.  Cross Device Authentication

   TODO

6.3.  Identity Association

   TODO

6.4.  Updating Identity Association

   TODO

6.5.  Disabling Site Login

   TODO

6.6.  Re-Enabling Site Login

   TODO








Comley                   Expires August 21, 2018               [Page 20]

Internet-Draft                    SQRL                     February 2018


7.  IANA Considerations

   TODO

8.  Security Considerations

   As SQRL aims to protect a single identity that is ultimately used to
   authenticate a user everywhere, the security of this identity is
   paramount.  Further, users must face many of the same security issues
   as with traditional methods of authentication.

   It is important to consider the following attack goals:

   1.  Session hijacking

   2.  Site credential theft

   3.  Association of SQRL identity to site account

   4.  Master key theft

   5.  Breaking of pseudonymous nature of SQRL authentication
       (association of SQRL identities on various sites)

8.1.  Phishing

   One well-known attack mode is where the user is invited to click on a
   link appearing to go to a legitimate site, but is in reality directed
   to an attacker's server.

   One common method of this is a look-alike link.  For example, a user
   believing he is going to example.com is in reality going to
   examp1e.com (the lowercase "l" is replaced with a numeral "1").  A
   historical example is "tvvitter.com" (the letter "v" twice instead of
   a "w").

   Another method is to use a malformed URL to misdirect a user.  For
   example, this link:

   https://www.amazon.com@%67%72%63.%63%6f%6d/

   at first glance appears to be a link to Amazon, but in reality takes
   the user to grc.com.  In reality, the attacker would substitute the
   name of his phishing site and most users might be fooled entirely.

   The phishing site is generally set up to look and work exactly the
   way the real site works, at least up until the point where the
   attacker has stolen the intended data.



Comley                   Expires August 21, 2018               [Page 21]

Internet-Draft                    SQRL                     February 2018


   Phishing attacks where the goal is to obtain authentication
   credentials are entirely foiled by SQRL.  Since SQRL uses the domain
   name as the basis for authentication, it will create completely
   different identity keys.  The SSPK the attacker gets will be a public
   key specifically for his attack site, useless to him for obtaining
   access to the real site.

   However, the attacker may have other goals.  If the attacker can
   successfully mimic an e-commerce site such as Amazon or a financial
   site such as PayPal, the user could be tricked into entering account
   data such as a credit card number.  The real domain name is displayed
   to the user before authentication, giving him the opportunity to
   realize he is being fooled.

   Many phishing attacks are pass-through attacks, where the phishing
   site acts as an active Man-In-The-Middle.  It obtains the genuine
   page from the real site and passes it along to the user, receiving
   the user's responses and passing them back to the site.  In the case
   of same-device authentication (Section 6.1), the client will be
   warned of an IP mismatch, and CPS will redirect the browser to a safe
   page on the real site.  No such protections exist for cross-device
   authentication (Section 6.2), but this is only used in the case of
   untrusted devices where the user will probably be typing in the
   domain name manually.

   The attacker can get around SQRL's protections with DNS spoofing,
   where the device's DNS addresses are altered, entries are added to
   the hosts file, or otherwise made to redirect a host name to an
   incorrect address, generally the phishing site controlled by the
   attacker.  In such a case, SQRL would be fooled (as would anything
   else on the compromised device).

   However, cross-device authentication would foil this, as the user
   would be using a smartphone or other trusted device that would be
   doing its own DNS lookup.  Local authentication should take place
   only on trusted devices.  DNS could only be spoofed on these devices
   using malware, but malware can compromise any security feature.

   A client developer could also foil such an attack by providing its
   own internal DNS resolver, bypassing the attacker's spoofing.
   However, such a feature may not be desired on enterprise networks
   running their own internal DNS systems, so it should be an option the
   user can turn off.








Comley                   Expires August 21, 2018               [Page 22]

Internet-Draft                    SQRL                     February 2018


8.2.  Shoulder-Surfing

   Shoulder-surfing is when an attacker reads or scans the display,
   keyboard, and other components of the target's device directly,
   allowing the attacker to see sensitive information, including
   information entered into forms.

   In the context of SQRL, the danger is of an attacker scanning the QR
   code of a SQRL-enabled website.  With good timing, the attacker could
   fool the user into thinking he's logged in as himself when in reality
   he's authenticated to an account controlled by the attacker.  The
   attacker could then get anything the user enters into that web site,
   including credit card numbers and other sensitive information.

   However, in such a case the user's authentication would fail as the
   nut is no longer valid.  The SQRL client MUST deliver an error
   message to the user saying that the authentication has failed, and
   SHOULD advise the user of the dangers of continuing to use the web
   site, especially if the authentication has the appearance of having
   worked.

   Care should be taken when authenticating to a website in a public
   area, or any other place where others could see the QR code, or watch
   the user type the Master Password on the keyboard.  Keep in mind that
   these can be picked up using binoculars or seen on a CCTV camera.

   It is absolutely crucial that a new SQRL identity NOT be created, and
   an existing one NOT be re-keyed, in such an area.  Anyone who can
   resolve the screen and keyboard can get the Master Password AND the
   Rescue Code.

8.3.  Evil Router

   In this context, the router in consideration is the one connecting
   the user's LAN segment to the rest of the Internet.  Home routers
   have been shown to be lacking in security, and even a well-supported
   router must be updated when new firmware versions are released,
   something most users aren't aware of.

   It is also increasingly the case that users connect to Wi-Fi hotspots
   when travelling, relying on routers whose security they could not
   evaluate even if they knew to.  Moreover, an attacker on the LAN
   segment could engage in ARP spoofing to make the attacker's own
   device the default gateway for the segment, forwarding the packets on
   to the true router but establishing himself as a Man-In-The-Middle.

   Once an attacker gains control of the default gateway, he could
   engage in phishing and DNS spoofing attacks as described above.  More



Comley                   Expires August 21, 2018               [Page 23]

Internet-Draft                    SQRL                     February 2018


   significantly, he could insert himself into the TLS handshake and
   commit any number of attacks designed to compromise the security of
   TLS.

   SQRL provides no means of defending the user against such an attack,
   however, at most the attacker will gain access to the specific login
   sessions the user makes while at that location.

8.4.  Server Compromise

   A server compromise can result in sensitive user data being obtained
   by the attacker without the user even logging in.

   In the case of SQRL there is less critical data for the attacker to
   get.  There are no passwords or other secrets sent to the server that
   have to be hashed and protected.  The attacker can only get the SSPK,
   SUK, and VUK, which are useless to him.

   If the attacker has gained access to more than one site, the SSPK
   would be different, meaning that the attacker could not correlate
   user data between websites (unless, of course, there was other
   identifying information in common such as an email address).

   All the same, once authenticated the user is subject to all of the
   harms that can occur regardless of the form of authentication.

8.5.  CPU Flooding

   CPU flooding is where the attacker is able to cause one or more
   processes to run that take up significant CPU time.  It also can
   happen without a malicious attacker, when a normal process starts
   running in the background.

   With SQRL, this can be a vulnerability when running EnScrypt
   (Section 2.4) in Timer Mode.  After 5 seconds (by default), the timer
   runs out, and the resulting key is used to encrypt the identity and
   the number of iterations recorded.  If another process utilizes
   significant CPU clocks during this process, the total number of
   iterations will be lower than it would have, meaning that the Master
   Password has weaker protection against cracking.

8.6.  Evil Client

   An evil client is a maliciously-developed SQRL client.  It may take
   the form of its own client, or it may mimic an existing and trusted
   SQRL client.  It may enter the user's computer in the form of
   malware, hijacking the sqrl:// protocol as a new handler and




Comley                   Expires August 21, 2018               [Page 24]

Internet-Draft                    SQRL                     February 2018


   attaching itself to the localhost:25519 port.  If artfully done, the
   user would have no clue that a substitution has been made.

   The consequences cannot be overstated.  The evil client would be able
   to gain the unencrypted IMK on its very first use, allowing the
   attacker to be able to hijack ANY account on ANY website where the
   user has authenticated using SQRL.

   Moreover, it could keep track of everywhere the user logs in and send
   to the attacker all of the user's accounts on banking, e-commerce,
   and other important websites.  And although a user can re-key his
   identity, he would first have to understand that his identity has
   been compromised.

   The absolute worst case scenario would be when a user uses an evil
   client to create or re-key his identity, which would give the
   attacker access to even the Rescue Code.  All other possible security
   concerns pale to this.

   SQRL mitigates this possibility by requiring (and advising) only that
   the user place his SQRL identity on trusted devices, using cross-
   device authentication on all other devices.  However, this only
   limits the attack surface.  In the past, fake versions of Firefox and
   other web browsers, fake Bitcoin wallets, and numerous others have
   been downloaded by users and even placed inside the trusted app
   stores for Android and iOS.  A malicious SQRL app, sadly, is not out
   of the question.

   This issue can be somewhat mitigated by requiring that SQRL apps be
   certified by trusted authorities.  The reference implementation from
   GRC not only checks the certificate on every update, but checks the
   fingerprint on the DigiCert root certificate as well to help ensure
   that there was no improper substitution.  However, the ultimate
   protection can only come from complete SQRL integration into web
   browsers and operating systems, which will refuse to let any other
   software hijack the sqrl:// protocol and eliminate the need for a
   localhost connection on port 25519.

9.  References

9.1.  Normative References

   [FIPS.180-4.2015]
              National Institute of Standards and Technology, "Secure
              Hash Standard", August 2015.






Comley                   Expires August 21, 2018               [Page 25]

Internet-Draft                    SQRL                     February 2018


   [NIST.800-38D]
              Dworkin, M., "NIST Special Publication 800-38D:
              Recommendation for Block Cipher Modes of Operation:
              Galois/Counter Mode (GCM) and GMAC.", November 2007.

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997, <https://www.rfc-
              editor.org/info/rfc2104>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997, <https://www.rfc-
              editor.org/info/rfc2119>.

   [RFC2898]  Kaliski, B., "PKCS #5: Password-Based Cryptography
              Specification Version 2.0", RFC 2898,
              DOI 10.17487/RFC2898, September 2000, <https://www.rfc-
              editor.org/info/rfc2898>.

   [RFC3548]  Josefsson, S., Ed., "The Base16, Base32, and Base64 Data
              Encodings", RFC 3548, DOI 10.17487/RFC3548, July 2003,
              <https://www.rfc-editor.org/info/rfc3548>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.

   [RFC7914]  Percival, C. and S. Josefsson, "The scrypt Password-Based
              Key Derivation Function", RFC 7914, DOI 10.17487/RFC7914,
              August 2016, <https://www.rfc-editor.org/info/rfc7914>.

   [RFC8031]  Nir, Y. and S. Josefsson, "Curve25519 and Curve448 for the
              Internet Key Exchange Protocol Version 2 (IKEv2) Key
              Agreement", RFC 8031, DOI 10.17487/RFC8031, December 2016,
              <https://www.rfc-editor.org/info/rfc8031>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017, <https://www.rfc-
              editor.org/info/rfc8032>.

9.2.  Informative References







Comley                   Expires August 21, 2018               [Page 26]

Internet-Draft                    SQRL                     February 2018


   [RFC4868]  Kelly, S. and S. Frankel, "Using HMAC-SHA-256, HMAC-SHA-
              384, and HMAC-SHA-512 with IPsec", RFC 4868,
              DOI 10.17487/RFC4868, May 2007, <https://www.rfc-
              editor.org/info/rfc4868>.

9.3.  URIs

   [1] https://android-developers.googleblog.com/2013/08/some-
       securerandom-thoughts.html

Appendix A.  SQRL Client Best Practices

   TODO

Appendix B.  SQRL Server Best Practices

   TODO

Appendix C.  Harvesting Entropy

   Secure cryptographic systems depend on the ability to create quality
   random numbers, and SQRL is no different in this regard.  SQRL's
   needs are meager compared to many other functions and protocols, but
   critical.

   The use of a pseudo-random function to generate random numbers is
   only as good as the entropy it is seeded with.  As RFC4086 points
   out, a hacker may find it easier to reproduce the environment a PRF
   was running in when it produced the secret quantities than to make
   blind guesses through the search space.  [RFC4086]

   Optimally, the numbers used for seeding cryptographic functions such
   as Curve25519 should be truly random, but what constitutes "truly
   random" is regarded as much philosophy as computer science.  However,
   a good working definition of "truly random" is one where the amount
   of entropy in a number is equal to its length; e.g., a 256-bit number
   that contains 256 bits of entropy.

   Unfortunately, determining the amount of entropy in an information
   stream is tricky at best.  But entropy is never reduced as more
   information is added; even weak sources of entropy, when added
   together, can produce sufficient entropy.  For that reason, none of
   the data collected during entropy harvesting should be discarded.

   The method recommended by SQRL is to harvest as much entropy as
   possible from as many uncorrelated sources as possible in the time
   available, and run the data stream through SHA-256 or SHA-512,
   depending on how much randomness is needed.  The Secure Hashing



Comley                   Expires August 21, 2018               [Page 27]

Internet-Draft                    SQRL                     February 2018


   Algorithm should change half the bits of the output when just a
   single bit of the input is changed, so the entropy should be
   preserved up to the length of the resulting hash.  The technique,
   then, is to hash an amount of data where the entropy content almost
   certainly far exceeds 256 or 512 bits.  These amounts are fairly
   trivial.

   For more about entropy harvesting, see RFC4086.

C.1.  Entropy Sources

   Sources of entropy vary greatly depending on the hardware, operating
   system, and other aspects of the client device.

C.1.1.  Operating System

   All operating systems have a source of randomness available (e.g.,
   /dev/random on UNIX-like systems), but developers should think twice
   before relying solely on these.  Flaws and backdoors could result in
   a false sense of security.  For example, in 2013 a flaw in Android's
   SecureRandom function made wallets generated on those devices
   vulnerable to remote hacking and the theft of funds, even without
   access to the device.  See Klyubin, Alex, "Some SecureRandom
   Thoughts," Android Developers Blog, 14 August 2013. [1]

   Developers should also be advised that many of these use some of the
   same techniques described below, meaning that utilizing the same
   technique might not result in as much entropy as estimated.

C.1.2.  Hardware

   Hardware sources can be very effective at harvesting entropy, but
   care must be taken to make sure that they exist on a particular
   implementation, and that the hardware hasn't failed in some way.

   The system clock has traditionally been used as a source of
   randomness, although it must be considered that users are more likely
   to generate the random numbers at some times of the day than others.
   Subseconds provide the greatest entropy here.

   Some systems come with embedded hardware that produce noise
   specifically for the purpose of seeding PRFs.

   Wireless networking devices can be polled for signal strength and
   other data.






Comley                   Expires August 21, 2018               [Page 28]

Internet-Draft                    SQRL                     February 2018


   Processor statistics can be a significant source, such as cache hits/
   misses and other low-level system counters, voltage, fan speed, and
   thermal data.

   Sound from a microphone could be a source of high-quality entropy in
   a typical room with air conditioning, fans, and other source of
   noise, as well as interference on the sound channel.  In such a case,
   a fraction of a second--less than two hundredths--would be
   sufficient, but as there is no guarantee longer periods should be
   considered.

   One or two frames from a camera can likewise be a source of high-
   entropy noise because of the sensor, which is especially the case if
   the SQRL client can set the camera's ISO to a high number.  Most cell
   phones in particular have cameras that generate sufficient noise in
   the low-order bits.  A single 640x480 frame would likely be
   sufficient for SQRL's purposes.  Care must be taken to ensure the
   client is getting the raw camera data, not compressed data which may
   have much of the noise removed.

   Free bytes of memory and storage space can vary quite a bit, adding a
   not insignificant amount of entropy.

   Network statistics, such as packet arrival time, can be effective,
   but only if it can be ensured that these are not subject to
   manipulation.

C.1.3.  User

   The user can provide a good measure of entropy, either directly by
   the client engaging the user, or indirectly.

   Examining mouse movements or keyboard strokes can be a source of
   entropy, although how much is a matter of some debate.

   Accelerometer data on cell phones and other such devices can pick up
   minute movements of the user's hand, even if the user is trying to
   hold it steady.

Author's Address

   Adam Comley (editor)

   Email: adam@novators.net







Comley                   Expires August 21, 2018               [Page 29]
