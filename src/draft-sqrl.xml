<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. --><!ENTITY RFC2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2898 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2898.xml">
<!ENTITY RFC3548 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3548.xml">
<!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4868 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4868.xml">
<!ENTITY RFC7914 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7914.xml">
<!ENTITY RFC8031 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8031.xml">
<!ENTITY RFC8032 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8032.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-sqrl-working"><!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" --><!-- ***** FRONT MATTER ***** --><front><!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters --><title abbrev="SQRL">Secure Quick Reliable Login (SQRL), an Authentication and Identity Management Framework</title><!-- add 'role="editor"' below for the editors if appropriate --><!-- Another author who claims to be an editor --><author fullname="Adam Comley" initials="A.C." surname="Comley"><address><postal><street/><!-- Reorder these if your country does things differently --><city/><region/><code/><country/></postal><email>adam@novators.net</email><!-- uri and facsimile elements may also be added --></address></author><author fullname="Shane Killian" initials="S.D." surname="Killian"><address><postal><street/><city/><region/><code/><country/></postal><email>shane@shanekillian.org</email></address></author><date month="February" year="2018"/><!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
     in the current day and month for you. If the year is not the current one, it is 
     necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
     purpose of calculating the expiry date).  With drafts it is normally sufficient to 
     specify just the year. --><!-- Meta-data Declarations --><area>General</area><workgroup>Internet Engineering Task Force</workgroup><!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
     If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. --><keyword>sqrl</keyword><!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. --><abstract><t>Secure Quick Reliable Login (SQRL) is an application-level protocol for user authentication and identity management.  It enables a user to create and manage a single pseudonymous lifetime identity.  That identity will allow the user to securely authenticate with any SQRL enabled server without relying on a third party or disclosing personally identifiable information.</t><t/><t>It provides:<list style="symbols"><t>Unique pseudonymous identifiers for each site</t><t>Separation of identity management from account management</t><t>Strong anti-phishing protection</t><t>No shared secrets that can be exploited by bad actors</t><t>Out-of-band authentication for logging in on untrusted devices</t></list></t></abstract></front><middle><section title="Introduction"><section title="Purpose"><t>Secure Quick Reliable Login (SQRL) is an authentication method and identity management framework which gives the user complete control over their online identity, including provisions for recovering from the loss of their identity file or password and recovering from potential security breaches.</t></section><section title="Features"><t><list style="hanging" hangIndent="3"><t hangText="Secure"><vspace/>
              Through a series of cryptographic signatures, the user can prove 
              their identity without disclosing any information that would allow 
              that identity to be compromised or their account hacked. SQRL also provides strong anti-phishing features.
            </t><t hangText="Identity Management"><vspace/>
              SQRL separates and delineates the concepts of account and identity. The user is given full control over their identity and its full life cycle, while leaving servers with complete control over account issues. SQRL provides a full identity lifecycle management framework which allows the user to maintain complete control of their identity.  Even in the event of a compromise, the user retains the ability to retake control of their identity and lock the attacker out.  Automated rekeying means that the user can maintain a single SQRL identity indefinitely, even after a compromise.
            </t><t hangText="Global Password"><vspace/>
              The user only has to remember a single password, which is used to 
              locally decrypt their identity during SQRL authentication.  Since 
              the user no longer has to remember a unique password for each site, 
              this one global password can be very strong.  This strong password 
              combined with strong encryption makes it infeasible for even a 
              state level actor to compromise the user's identity. (SQRL apps can alternately use other methods of protection such as biometrics when available on the host device.)
            </t><t hangText="Pseudononymous"><vspace/>
              SQRL authentication is pseudonymous, in that it only provides a 
              secure, site-specific token to the server.  This token cannot be 
              directly linked to a user's account at any other server, and 
              provides no personally identifiable information.
            </t><t hangText="No Shared Secrets"><vspace/>
              Passwords, time-based authenticators, and other authentication methods work through shared secrets. These secrets can conceivably be stolen by hackers or rogue employees and used to impersonate the user. SQRL does not operate through shared secrets, and even if the server's account database is stolen the attacker is not given any means to impersonate the user.
            </t><t hangText="No Third Party"><vspace/>
              The user's identity cannot be compromised by a security breach at 
              a third party authentication provider, protecting it from both 
              hackers and overreaching authorities.
            </t><t hangText="No Per-Site Settings"><vspace/>
              Unlike password managers, SQRL does not require any information about specific websites to be saved, preventing potential privacy issues stemming from information leaks as well as keeping its database size small.
            </t><t hangText="Offline Identity Backup"><vspace/>
              Since SQRL identities are intended to last a lifetime, and there 
              is no third party that can help the user recover their identity if 
              they forget their password, SQRL includes an offline backup 
              mechanism.  The user can print out or write down their encrypted 
              identity, along with a secure Rescue Code, that will allow the user 
              to recover from a forgotten password.
            </t><t hangText="Out Of Band Authentication Option"><vspace/>
              With SQRL, the user can safely authenticate a session on public or 
              potentially compromised systems by scanning a QR code 
              on a trusted mobile device containing their SQRL identity, without the need to expose that identity to the public system.
            </t></list></t></section><section title="Requirements Language"><t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.</t></section><section title="Definitions"><t><list style="hanging" hangIndent="3"><t hangText="Account"><vspace/>  Information on a user's services and permissions on a particular web site for purposes of facilitating access</t><t hangText="Authentication"><vspace/>The process of verifying an identity and attaching it to an account</t><t hangText="Backup">To externally save a user's Rescue Code-protected IUK via file, QR code, or text without saving the IMK<vspace/></t><t hangText="Client"><vspace/>The user component of SQRL</t><t hangText="Export"><vspace/>To externally save a user's Rescue Code-protected IUK and password-protected IMK via file, QR code, or text</t><t hangText="Identity"><vspace/>A means of pseudonymously recognizing a user</t><t hangText="Identity Lock"><vspace/>A method of locking a user's identity on various websites (generally out of fear the user's IMK may be compromised) for later unlocking with Rescue Code or rekeyed identity</t><t hangText="ILK"><vspace/>Identity Lock Key: public key counterpart to the IUK</t><t hangText="IMK"><vspace/>Identity Master Key: A key derived from the IUK that is the basis of a user's identity for each realm</t><t hangText="Import"><vspace/>To load an exported or backed up identity into a client</t><t hangText="IUK"><vspace/>Identity Unlock Key: the master key from which all aspect's of a user's identity are derived</t><t hangText="Master Password"><vspace/>A password created by the user that is used to derive the encryption key for the user's IMK</t><t hangText="Nut"><vspace/>A unique, unpredictable, cryptographically-strong string identifying the current session</t><t hangText="Pseudonymous"><vspace/>Of a consistent and reliable means of verifying a user without having to obtain personal information</t><t hangText="Realm"><vspace/>The basis for generating a unique identity key; generally the domain name, but additional data can be included (ref)</t><t hangText="Rekey"><vspace/>To replace a potentially-compromised IMK</t><t hangText="Rescue Code"><vspace/>A cryptographically-strong 24 decimal digit random number that is used to derive the encryption key for the user's IUK</t><t hangText="RLK"><vspace/>Random Lock Key: generated randomly by a user for a new website and used as the basis of the Identity Lock system</t><t hangText="Server"><vspace/>The backend component of SQRL that verifies a user identity and attaches it to an account</t><t hangText="ShortPass"><vspace/>The first few characters (4 by default) of a user's Master Password; used to verify the user after the Master Password has been used to start a session</t><t hangText="SSPK"><vspace/>Site-Specific Public Key: a secure, irreversible, and collision-resistant public key used to identify the user in a specific realm; unique to both the realm and the user's IMK</t><t hangText="SUK"><vspace/>Server Unlock Key: public key counterpart to the RLK; sent by the user to the server on account creation and used to unlock an identity</t><t hangText="VUK"><vspace/>Verify Unlock Key: public key counterpart to a Diffie-Hellman key generated by the RLK and the ILK; later used to verify an unlock request from the user made from the SUK and the user's IUK</t></list></t></section></section><section title="Algorithms"><t>TODO</t><section title="Standard Algorithms"><t>The following standard algorithms are used in this document:
          <list style="symbols"><t><xref target="NIST.800-38D">AES-GCM</xref></t><t>
              base64url: URL safe base64 encoding, as defined in Section 4 of 
              <xref target="RFC3548"/>, without padding.
            </t><t><xref target="RFC8031">Curve25519</xref></t><t><xref target="RFC8032">Ed25519</xref></t><t><xref target="RFC2104">HMAC</xref></t><t><xref target="RFC4868">HMAC-SHA256</xref></t><t><xref target="RFC2898">PBKDF2</xref></t><t><xref target="RFC7914">scrypt</xref></t><t><xref target="FIPS.180-4.2015">SHA-256</xref></t><t>
              urlencode: Percent-Encoding as defined in Section 2.1 of 
              <xref target="RFC3986"/>.
            </t></list>
        </t></section><section anchor="algo-b56c" title="base56check"><t>
          base56check encoding allows the backup of SQRL identities to a 
          textual form.  It:
          <list style="symbols"><t>Accepts an arbitrarily sized payload.</t><t>
              Uses a set of 56 alphanumeric symbols chosen to be easily 
              distinguishable in any font.
            </t><t>
              Ignores invalid characters and white space to allow readable 
              formatting.
            </t><t>
              Designed to be printed 20 characters per line, in 5 space 
              separated groups of 4 characters for readability.
            </t><t>
              Includes a check character at the end of each line to catch 
              errors while the user is typing with 98.2% accuracy.
            </t></list>
          The chosen alphabet is:
        </t><figure><artwork><![CDATA[
23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz
        ]]></artwork></figure><section title="Encoding"><t>
            To encode a series of bytes to base56check, treat the source bytes 
            as a single, large, little-endian number and convert using the 
            normal mathematical steps:
            <list style="format %d." counter="b56-encode-counter"><t>Calculate BASE_LENGTH:  ceil( SOURCE_LENGTH * 8.0 / log2(56))</t><t>Divide SOURCE by 56 to yield SOURCE and REMAINDER.</t><t>
                Append the character in ALPHABET at position REMAINDER to the 
                BASE string.
              </t><t>Repeat from step 1, until SOURCE is zero.</t><t>Append '2' (character in ALPHABET at position 0) to BASE until BASE is BASE_LENGTH bytes long.</t></list>
            Now, with our converted BASE string, we can calculate the check 
            digits and produce the final output.
            <list style="format %d." counter="b56-encode-counter"><t>
                Split BASE into 19 character CHUNKS (the final chunk may be 
                smaller).
              </t><t>
                For each CHUNK:
                <list style="letters"><t>Append a single byte zero-based CHUNK-NUMBER to the CHUNK.</t><t>Perform a SHA-256 hash on the CHUNK, yielding HASH.</t><t>
                    Treating HASH as a single little-endian number, divide 
                    HASH by 56 to obtain REMAINDER.
                  </t><t>
                    Replace the last character in CHUNK with the character in 
                    ALPHABET at position REMAINDER.
                  </t><t>Append the CHUNK to OUTPUT.</t></list>
              </t></list>
            OUTPUT can then be formatted as desired.  The RECOMMENDED 
            formatting is 20 characters per line in space-separated groups of 
            4 characters each.  This format is easy for humans to read and type, 
            and allows error checking for each line of input.
          </t></section><section title="Validation"><t>
            base56check is designed to provide periodic error checking and 
            feedback to the user as they are typing.  To perform this validation:
            <list style="numbers"><t>Remove any characters from INPUT that are invalid (not included in ALPHABET).</t><t>Split INPUT into 20 character CHUNKS (the final chunk may be smaller).</t><t>For each CHUNK:
                <list style="letters"><t>Store the last character from CHUNK as CHECK.</t><t>Replace the last character in CHUNK with a single byte zero-based CHUNK-NUMBER.</t><t>Perform a SHA-256 hash on the CHUNK, yielding HASH.</t><t>Treating HASH as a single little-endian number, divide HASH by 56 to obtain REMAINDER.</t><t>Compare CHECK with the character from ALPHABET at position REMAINDER.</t><t>If comparison passes (is equal), continue.  Otherwise, there is an error in this CHUNK.</t></list>
              </t></list>
          </t></section><section title="Decoding"><t>
            Decoding base56check is similarly straight-forward:
            <list style="numbers"><t>
                Start with an empty BASE string and an zero OUTPUT buffer, to be 
                treated as a single, large, little-endian number.
              </t><t>
                Perform the base56check validation as described above, appending 
                all but the last character of each validated CHUNK to the 
                BASE string.
              </t><t>If any chunk fails validation, abort.</t><t>For each CHARACTER in BASE, from right to left:
                <list style="letters"><t>Multiply OUTPUT by 56.</t><t>Lookup the INDEX of CHARACTER in ALPHABET.</t><t>Add INDEX to OUTPUT.</t></list>
              </t></list>
          </t></section></section><section anchor="algo-enhash" title="EnHash"><figure><preamble>
            EnHash is an iterated hash used to derive a 256 bit key from 
            another 256 bit key.  It is performed by chaining 16 iterations 
            of SHA-256, with each iteration's output XORed to produce the 
            final output as follows:
          </preamble><artwork><![CDATA[
function EnHash ( input := 32 byte key )
{
  output := 32 byte buffer;

  set output to all NULL (0) bytes;

  repeat {
    input = SHA256( input );
    output = output XOR input;
  } 16 times;

  return output;
}
          ]]></artwork></figure></section><section anchor="algo-enscrypt" title="EnScrypt"><t>
          EnScrypt is an iterative construct based on the scrypt password based 
          key derivation function.  It hardens scrypt by allowing for extended 
          processing time.  The following parameters are used for the scrypt 
          function:
        </t><texttable anchor="table_enscrypt_parameters" title="scrypt parameters"><ttcol>dkLen</ttcol><ttcol>N</ttcol><ttcol>r</ttcol><ttcol>p</ttcol><c>32</c><c>512 (1&lt;&lt;9)</c><c>256</c><c>1</c></texttable><t>
          In this document, we may refer to an additional parameter, "n-factor" or
          just "n".  This is simply a shorthand way of storing the N parameter.
          N is derived from n as follows:
          <figure><artwork><![CDATA[
N = (1 << n);
          ]]></artwork></figure>
        </t><t>
          Enscrypt is performed by calling scrypt in multiple rounds, with each 
          successive round accepting the previous round's output as its salt.  
          The final output is the XOR of each round's scrypt result.
        </t><texttable anchor="table_enscrypt_rounds" title="EnScrypt Rounds"><ttcol>Round #</ttcol><ttcol>let salt[n] = </ttcol><ttcol>let out = </ttcol><c>1</c><c>scrypt( password, salt )</c><c>salt[1]</c><c>2</c><c>scrypt( password, salt[1] )</c><c>salt[1] XOR salt[2]</c><c>n</c><c>scrypt( password, salt[n-1] )</c><c>salt[n-1] XOR salt[n]</c></texttable><t>
          EnScrypt can operate in two different modes, the only difference 
          being when the calculation is stopped.
          <list style="hanging" hangIndent="3"><t hangText="Counter Mode:"><vspace/>
              Stops after a predefined number of iterations.
            </t><t hangText="Timer Mode:"><vspace/>
              Stops after a desired amount of time has passed (5 seconds by default).
            </t></list>
        </t><t>Timer Mode is used when creating an encryption key from a password. Once the key is derived and the identity encrypted, the resulting number of iterations is saved with the identity file. Counter Mode is used to recreate this key and decrypt the identity.</t></section></section><section title="Cryptographic Keys, Secrets, and Passwords"><t>
        SQRL uses a wide variety of secrets in various operations.
      </t><section anchor="secret-class-a" title="Class A Secrets"><t>
          Class A secrets are absolutely critical to protecting a user's 
          identity.  A compromised Class A secret may result in the user's 
          complete loss of control of the identity, with no recourse available.  
          Due to their highly sensitive nature, the following precautions are 
          REQUIRED when dealing with Class A secrets:
          <list style="symbols"><t>
              The secret MUST be generated using the highest quality entropy 
              source available to the client.  See <xref target="app-entropy"/> 
              for recommendations.
            </t><t>
              The client MUST prevent the secret from being written to 
              non-volatile memory in plaintext form, including being swapped to 
              disk, by any means possible.
            </t><t>
              The plaintext secret MUST be securely wiped from RAM as soon as 
              it is no longer needed.
            </t><t>
              If the secret is to be stored, it MUST be stored in an offline 
              format (printed), OR encrypted using a Class A key.
            </t><t>
              The secret SHOULD NOT be transmitted over the network in any form, 
              and MUST NOT be transmitted unencrypted.
            </t></list>
        </t><section title="Identity Unlock Key (IUK)"><figure><artwork><![CDATA[
IUK = RandomBytes( 32 );]]></artwork></figure><t>
            The IUK is a Class A 256 bit high entropy random number that 
            represents a user's identity.  All other identifying keys are 
            derived from this one.  After identity creation, this key is only 
            used in emergency situations, such as rekeying an identity in the 
            event of a possible compromise.
          </t></section><section title="Unlock Request Signing Key (URSK)"><figure><artwork><![CDATA[
URSK = curve25519_key_agreement( SUK, curve25519_private_key( IUK ));]]></artwork></figure><t>
            Used by the client to update the identity association on a server, 
            the URSK is derived from the SUK and IUK.
          </t></section><section title="Rescue Code (RC)"><t>
            The Rescue Code is a Class A, computer generated, high entropy 
            passcode consisting of 24 numeric digits.  The client SHOULD
            encourage the user to store the Rescue Code in an offline format 
            (printed or written).
          </t></section><section title="Password Derived Keys"><t>
            Several keys are generated from user input.  Both the user supplied 
            passwords and the derived keys are to be treated as Class A secrets.  
            Since these are expected to be low entropy, they must be processed 
            through EnScrypt (<xref target="algo-enscrypt"/>).  When generating 
            derived keys, EnScrypt MUST be used in timer mode with a minimum 
            duration of 1 second.  The table below lists RECOMMENDED durations 
            for EnScrypt key generation:
          </t><texttable anchor="table_pw_derived_keys" title="Password Derived Keys and Recommended EnScrypt Times"><ttcol>Key</ttcol><ttcol>Abbreviation</ttcol><ttcol>EnScrypt Time</ttcol><c>Password Derived Key</c><c>PWDK</c><c>5 seconds</c><c>Short Password Derived Key</c><c>SPDK</c><c>1 second</c><c>Rescue Code Derived Key</c><c>RCDK</c><c>60 seconds</c></texttable><t>
            Clients MAY allow the user to specify the EnScrypt time for the PWDK, 
            as long as that timer is at least 1 second.  The RCDK is used so 
            rarely, and is so important to protect, that 60 seconds should not 
            cause an undue burden on the user.  
          </t><t>
            When re-generating derived keys, EnScrypt is used in counter mode 
            with the iteration count from the original generation operation.
          </t></section></section><section anchor="secret-class-b" title="Class B Secrets"><t>
          Class B secrets are used often, and have less strict security 
          requirements.  A compromised Class B secret may result in an attacker 
          temporarily gaining the ability to impersonate the user to any server,
          but the user can regain control of their identity by rekeying followed 
          by authenticating with each affected server.  The following precautions 
          are REQUIRED when dealing with Class B secrets:
          <list style="symbols"><t>
              The client MUST prevent the secret from being written to non-volatile 
              memory in plaintext form, including being swapped to disk, by any 
              means possible.
            </t><t>
              The plaintext secret MUST be securely wiped from RAM as soon as it 
              is no longer needed.
            </t><t>
              If the secret is to be stored, it MUST be stored in an encrypted 
              form.
            </t><t>
              The secret SHOULD NOT be transmitted over the network in any form, 
              and MUST NOT be transmitted unencrypted.
            </t></list>
        </t><section title="Previous Identity Unlock Key (PIUK)"><t>
            A PIUK is an IUK that is no longer in active use.  It has been 
            replaced by a newly generated IUK, and requires less strict 
            protection.
          </t></section><section title="Identity Master Key (IMK)"><figure><artwork><![CDATA[
IMK = EnHash( IUK );]]></artwork></figure><t>
            This Class B key acts as a proxy for the IUK during normal SQRL 
            operation.  It is used to generate the unique keys that each site 
            associates with the user.  The IMK is derived from the IUK using 
            the EnHash (<xref target="algo-enhash"/>) function.
          </t></section><section title="Identity Lock Key (ILK)"><figure><artwork><![CDATA[
ILK = curve25519_public_key( curve25519_private_key( IUK ));]]></artwork></figure><t>
            The (modified) IUK and ILK together form a Curve25519 key pair.
          </t></section><section title="Site Specific Secret Key (SSSK)"><figure><artwork><![CDATA[
SSSK = HMAC-SHA256( IMK, Realm );]]></artwork></figure><t>
            The Site Specific Secret Key is generated from the IMK and the 
            Realm (<xref target="section-realm"/>).
          </t></section><section title="Random Lock Key (RLK)"><figure><artwork><![CDATA[
RLK = curve25519_private_key( RandomBytes( 32 ));]]></artwork></figure><t>
            The RLK is generated randomly when the client associates with a 
            new server.
          </t></section></section><section anchor="secret-class-c" title="Class C (Public) Keys"><t>
          Class C keys are not required to be kept secret.
        </t><section title="Site Specific Public Key (SSPK)"><figure><artwork><![CDATA[
SSPK = ed25519_public_key( SSSK );]]></artwork></figure><t>
            The Site Specific Public Key (SSPK) is the public counterpart to 
            the SSSK.  It serves as the user's pseudonymous identity on the site.
          </t></section><section title="Server Unlock Key (SUK)"><figure><artwork><![CDATA[
SUK = curve25519_public_key( RLK );]]></artwork></figure><t>
            Created during identity association, the SUK is the public 
            counterpart of the RLK.
          </t></section><section title="Verify Unlock Key (VUK)"><figure><artwork><![CDATA[
VUK = ed25519_public_key( curve25519_key_agreement( ILK, RLK ));]]></artwork></figure><t>
            Generated during identity association, and stored only on the 
            server, the VUK is the public key used to verify the client's 
            URSK.
          </t></section></section></section><section title="Identity Management"><section title="Identity Lifecycle"><t>
          TODO
        </t></section><section anchor="user-options" title="User Options"><t>
          Several user options are available which will affect the operation
          of compatible SQRL clients:
          <list style="hanging" hangIndent="3"><t hangText="ShortPass Length:"><vspace/>
              The number of characters from the user's password to use as the
              ShortPass (<xref target="app-shortpass"/>).  Clients that implement ShortPass MUST honor the user's
              choice here.  Valid values are 0 to 255.  A value of 0 disables the
              ShortPass feature.
            </t><t hangText="EnScrypt Seconds:"><vspace/>
              The number of seconds to run EnScrypt when deriving the PWDK.  The
              RECOMMENDED default is 5 seconds.  The REQUIRED minimum is 1 second.
            </t><t hangText="Idle Timeout:"><vspace/>
              If the client implements ShortPass or holds the user's password or keys
              in memory in any form, and the 0x0080 option flag is set, it MUST 
              securely erase that memory after this many minutes of system idle time.
              Valid values are 1-65535.
            </t><t hangText="Option Flags:"><vspace/>
              The following binary flags turn on or off various user options:
            </t></list>
        </t><texttable title="User Option Flags"><ttcol>Flag</ttcol><ttcol>Description</ttcol><c>0x0001</c><c>Check for updates:  Gives the client permission to periodically check for updates.</c><c>0x0002</c><c>Update Automatically:  Requests that the client automatically update itself when a new version is available.</c><c>0x0004</c><c>Request SQRL only:  Requests that servers disable other means of authentication and only allow SQRL.</c><c>0x0008</c><c>Request no bypass:  Requests that servers not allow non-SQRL account recovery options.</c><c>0x0010</c><c>Warn of possible MITM attack: The client will warn the user if their IP doesn't match the server's expectations.</c><c>0x0020</c><c>Clear ShortPass when screen blanks: The client will securely erase any ShortPass information when the screen saver is activated or the system is going to suspend / sleep modes.</c><c>0x0040</c><c>Clear ShortPass when changing users: The client will securely erase any ShortPass information when the system's active user changes.</c><c>0x0080</c><c>Clear ShortPass after idle timer: The client will securely erase any ShortPass information after the system has been idle for an amount of time specified in the "Idle Timeout" option.</c><c>0x0100</c><c>Warn of non-CPS authentication: The client will warn the user before a non-CPS authentication is attempted.  This flag MUST default to on.</c></texttable></section><section anchor="identity-storage" title="Identity Storage"><t>
          Because SQRL identities are intended to last the user's lifetime, 
          the user needs to be able to move his identity between clients.
          Every SQRL client MUST be able to read and write identities in this
          standard format.  The format described here is RECOMMENDED for both
          non-volatile and in-memory storage.  
        </t><t>
          Because identities should be backed up offline (to printed paper),
          the storage format must be compact enough to reliably fit in a
          printed QR code, and short enough to not cause undue burden if
          the user has to type it in by hand.
        </t><t>
          Values stored in standard SQRL storage format MUST follow these rules:
          <list style="symbols"><t>All numeric values are unsigned.</t><t>
              Multibyte numeric values are stored in little endian byte order,
              with the least significant byte first.
            </t><t>
              String values are stored in natural order, first byte first.
            </t></list>
        </t><section title="Storage Blocks"><t>
            A stored SQRL identity is composed of any number of blocks.  Each block
            begins with a four byte header identifying the total length of the block 
            and the type of data stored in the block.
          </t><texttable anchor="table-block-format" title="Storage Block Format"><ttcol>Field</ttcol><ttcol>Size (bytes)</ttcol><c>block length in bytes (n+4)</c><c>2</c><c>block type</c><c>2</c><c>block data</c><c>n</c></texttable><t>
            Standard block types are defined in the next section.  Clients MAY add
            their own block types to store additional information, but SHOULD
            consider types 0-255 as reserved for future official block types.
            Any client reading an identity that encouters a block type unknown to
            that client MUST simply ignore that block.
          </t></section><section title="Predefined Block Types"><section anchor="type-1-block" title="Block Type 1: Working Identity"><t>
              The type 1 block contains the user's encrypted IMK and ILK, as well as 
              user defined options.  The user options are in plain text, but MUST be 
              regarded as untrusted until authenticated through AES-GCM.  Type 1
              blocks are encrypted with AES-GCM using the PWDK.  The type 1 block is 
              formatted as follows:
            </t><texttable title="Type 1 Block"><ttcol>Field</ttcol><ttcol>Default</ttcol><ttcol align="right">Bytes</ttcol><c>Block Length</c><c>125</c><c>2</c><c>Block Type</c><c>1</c><c>2</c><c>AAD Length</c><c>45</c><c>2</c><c>AES-GCM IV</c><c/><c>12</c><c>EnScrypt Salt</c><c/><c>16</c><c>EnScrypt n-factor</c><c>9</c><c>1</c><c>EnScrypt Iteration Count</c><c/><c>4</c><c>User Option Flags</c><c>0x01F3</c><c>2</c><c>ShortPass Length</c><c>4</c><c>1</c><c>EnScrypt Seconds</c><c>5</c><c>1</c><c>Idle Timeout (minutes)</c><c>15</c><c>2</c><c>Encrypted IMK</c><c/><c>32</c><c>Encrypted ILK</c><c/><c>32</c><c>AES-GCM Verification Tag</c><c/><c>16</c></texttable><t>
              Constructing a type 1 block is relatively straight-forward:
              <list style="numbers"><t>Allocate a 125 byte buffer.</t><t>Populate the default values (or user chosen options).</t><t>Generate a random 12 byte initialization vector (IV) and store it in the buffer.</t><t>Generate a random 16 byte salt and store it in the buffer.</t><t>Use the generated salt, the user's password, and the user's chosen EnScrypt Seconds value to generate the PWDK and Iteration Count.</t><t>Populate the Iteration Count in the buffer.</t><t>AES-GCM encrypt the IMK and ILK (64 bytes total) using the first "AAD Length" bytes of the buffer as AAD, the IV, 
              the PWDK.</t><t>Populate the ciphertext result and verification tag from AES-GCM.</t><t>Securely wipe the plaintext keys, encryption key, and password from memory if they are no longer needed.</t></list>
              If the client is updating a type 1 block, and the user's password hasn't changed, 
              clients SHOULD use the original salt and iteration count to re-encrypt the block.
            </t></section><section anchor="type-2-block" title="Block Type 2: Rescue Identity"><t>
    The type 2 block contains a single key, the IUK, along with it's
    encryption parameters.  It is encrypted with AES-GCM using the RCDK.
  </t><texttable title="Type 2 Block"><ttcol>Field</ttcol><ttcol>Default</ttcol><ttcol>Bytes</ttcol><c>Block Length</c><c>73</c><c>2</c><c>Block Type</c><c>2</c><c>2</c><c>EnScrypt Salt</c><c/><c>16</c><c>EnScrypt n-factor</c><c>9</c><c>1</c><c>EnScrypt Iteration Count</c><c/><c>4</c><c>Encrypted IUK</c><c/><c>32</c><c>AES-GCM Verification Tag</c><c/><c>16</c></texttable><t>
    The type 2 block is constructed the same way as the type 1, with the following exceptions:
    <list style="symbols"><t>
        To save space in textual exports, we implicitly use a 12 byte, all zero Initialization Vector for AES-GCM.
        This means that the type 2 block MUST NOT be re-encrypted with different parameters.  This block MUST NOT
        be changed after identity creation.  It can only be replaced by rekeying.
      </t><t>The RCDK is used in place of the PWDK.</t></list>
  </t></section><section anchor="type-3-block" title="Block Type 3: Previous Identities"><t>
      The type 3 block contains from one to four of the most recent PIUKs, IUKs which have been replaced by rekeying.  
      It also includes the total number of times the identity has been rekeyed, the "Edition".  If the identity has 
      never been rekeyed, this block will be absent.  Encrypted using the IMK as the AES-GCM encryption key, the 
      content of this block is accessible to the client if either the user's password or the Rescue Code is known.
    </t><texttable title="Type 3 Block"><ttcol>Field</ttcol><ttcol>Default</ttcol><ttcol>Bytes</ttcol><c>Block Length</c><c>54, 86, 118, or 150</c><c>2</c><c>Block Type</c><c>3</c><c>2</c><c>Edition</c><c/><c>2</c><c>Previous IUKs</c><c/><c>32, 64, 96, or 128</c><c>AES-GCM Verification Tag</c><c/><c>16</c></texttable><t>
      The type 3 block is encrypted with AES-GCM, using the first 6 bytes of the block as AAD, the IMK as the encryption key,
      and a 12 byte all zero initialization vector (IV).  Due to the nature of the block's content, the same encryption key will
      never be used to encrypt a different set of data and AAD, so a random IV is not necessary.
    </t></section></section><section title="Encoding"><t>
      Identities may be stored to file or optical (QR) code in binary
      format, or in base64url or base56check (<xref target="algo-b56c"/>) 
      encoded text.  Compatible clients MUST support at least one of 
      these standard encodings.
    </t><t>
      Identities stored in this standard format MUST include an 8 byte
      header identifying the encoding used for the remainder of the file,
      with a single exception:  Identities exported to text using base56check
      encoding do not include a header.  Instead, they are validated by
      the encoded check characters.  The header itself is not encoded,
      but indicates that everything following it will be.
    </t><texttable anchor="table-id-encoding" title="Storage Encodings and Headers"><ttcol>Encoding</ttcol><ttcol>Header (ASCII)</ttcol><c>binary</c><c>sqrldata</c><c>base64url</c><c>SQRLDATA</c><c>base56check</c><c/></texttable></section></section><section title="Identity Operations"><t>
      Identity creation, recovery, and rekeying are particularly vulnerable times for the SQRL identity, during which
      several Class A secrets may be exposed.  Special care is required to protect this sensitive key during these operations.  
      Clients SHOULD inform the user of the security implications and encourage the user not to perform these operations
      on a device that the user believes to be compromised.
    </t><section anchor="identity-creation" title="Identity Creation"><t>
        The SQRL identity is, in essence, just a long random number (the IUK).  In order to protect the new identity, 
        both during creation and against future exploits, the client MUST use the highest quality entropy available to 
        it while creating a new identity.  See <xref target="app-entropy"/> for recommendations on harvesting entropy.
      </t><t>
        Creating an identity involves generating a random IUK and Rescue Code, deriving the IMK and ILK, and encrypting these
        keys.  In addition, the client MUST allow and encourage the user to store both the new identity and the Rescue Code in 
        an offline format.  The following process is RECOMMENDED:
        <list style="numbers"><t>Begin harvesting entropy if the client does not do this continuously.</t><t>Prompt the user to name their new identity so that they can recognize it later.</t><t>
            Generate a random Rescue Code, and have the user store the Rescue Code offline.  Written or printed form is RECOMMENDED.
            Encourage the user to securely store the Rescue Code in an offline format.  The client MAY require the user to retype
            the Rescue Code to ensure that they have stored a copy.
          </t><t>Prompt the user for a password to protect the new identity.  Clients SHOULD encourage the user to choose a strong password.</t><t>
            Generate a random IUK and store it in a newly constructed Type 2 block (<xref target="type-2-block"/>), encrypted with
            the newly generated Rescue Code.
          </t><t>
            Derive the IMK and ILK and store them in a newly constructed Type 1 block (<xref target="type-1-block"/>), encrypted with
            the user's new password.
          </t><t>Securely wipe any memory containing unencrypted keys or passwords.</t><t>Save the newly created blocks to local storage with the user chosen name.</t><t>Provide options for, and encourage the user to backup the new identity to an offline format.</t></list>
      </t></section><section anchor="identity-import-export" title="Importing / Exporting an Identity"><t>
          For compatibility, clients MUST support importing and exporting identities in at least one of these standard formats.  
          It is RECOMMENDED that clients support all of them.  Clients MAY offer additional formats as well.
          <list style="hanging" hangIndent="3"><t hangText="Binary File"><vspace/>
              An identity in the <xref target="identity-storage">standard format</xref>, saved as a binary file with the "sqrldata"
              header.  The RECOMMENDED file extension is ".sqrl".
            </t><t hangText="QR Code"><vspace/><list style="symbols"><t>TODO: Reference QR Code specification?</t><t>TODO: Recommend Mode, Encoding, Error Correction, etc.</t></list></t><t hangText="Text"><vspace/>
              An identity in the <xref target="identity-storage">standard format</xref>, encoded with 
              <xref target="algo-b56c">base56check</xref>, intended to be printed to paper for offline
              storage and manually entered by the user during import.
            </t></list>
        </t></section><section title="Changing the User's Password"><t>
          Clients SHOULD allow the user to change their password at any time.  The process is simple:
          <list style="numbers"><t>Using the user's current password, decrypt the Type 1 Block.  Other block types are not affected by this operation.</t><t>Using the user's new password, re-encrypt the Type 1 Block.  During encryption, EnScrypt MUST be called in Timer Mode, using
            the user's chosen "EnScrypt Seconds" option (<xref target="user-options"/>).</t><t>Save the changes to non-volatile storage.</t></list>
        </t></section><section anchor="identity-recovery" title="Identity Recovery"><t>
        If the user has forgotten their password, or lost their identity file, identity recovery is required to reconstruct 
        a usable identity.  Depending on the situation, the client may be recovering from an existing identity file, or from
        an offline backup.  In either case, the procedure is the same:
        <list style="numbers"><t>Because the user's options are lost in this process, the client SHOULD give the user an opportunity to review the default options and make changes.</t><t>Prompt the user to enter their Rescue Code and new password.</t><t>Validate the Rescue Code by decrypting the Type 2 block and obtain the IUK.</t><t>Derive the IMK and ILK, and construct a new Type 1 block protected by the user's newly chosen password.</t><t>Securely wipe any memory containing unencrypted keys or passwords.</t><t>Save the recovered identity.</t></list>
      </t></section><section anchor="identity-rekey" title="Rekeying an Identity"><t>
        Rekeying an identity completely replaces the IUK with a new one.  It is only required when the user believes that
        their identity may have been compromised.  After rekeying, the client SHOULD encourage the user to visit and authenticate
        with any important sites to ensure that those sites update their identity association.  Until this is done, an
        attacker may still have full access to those sites.  To rekey an identity:
        <list style="numbers"><t>Prompt the user for their Rescue Code.</t><t>Using the Rescue Code, decrypt the Type 2 block to obtain the IUK (now a PIUK).</t><t>
            Follow the steps in <xref target="identity-creation"/> to create a new identity.
          </t><t>
            Before saving or exporting the new identity, a Type 3 block (<xref target="type-3-block"/>) must be constructed:
            <list style="letters"><t>If a Type 3 block already exists (rekeying has been performed in the past), the existing block must be decrypted and
              modified.  The "Edition" field is incremented, and the new PIUK is prepended to the existing PIUKs.  If the list
              now contains more than four PIUKs, the last (oldest) one is removed.</t><t>If a Type 3 block does not already exist, a new one is created.  Fill the "Edition" field with the number 1.  The
              encrypted section will contain only the new PIUK.</t><t>Encrypt the Type 3 block using the new IMK and ensure that it is saved / exported with the new identity.</t></list>
          </t></list>
      </t></section></section></section><section title="Client-Server Protocol"><t>TODO</t><section title="Initiation of SQRL Authentication"><t>TODO</t><section title="The SQRL Scheme"><t>TODO</t></section><section title="QR Codes (Out of Band)"><t>TODO</t></section></section><section anchor="section-realm" title="The SQRL Realm (Domain)"><t>TODO</t></section><section title="Client to Server Requests"><t>TODO</t><section title="Protocol Version"><t>TODO</t></section><section title="Commands"><t>TODO</t></section><section title="Options"><t>TODO</t></section><section title="The server Value"><t>TODO</t></section><section title="The client Value"><t>TODO</t></section><section title="Client Keys"><t>TODO</t></section><section title="Client Signatures"><t>TODO</t></section><section title="Composing the Request"><t>TODO</t></section></section><section title="Server to Client Replies"><t>TODO</t><section title="Required Values"><t>TODO</t></section><section title="Optional Values"><t>TODO</t></section><section title="Additional Values"><t>TODO</t></section><section title="Composing the Reply"><t>TODO</t></section></section></section><section title="Client-Server Interactions"><t>TODO</t><section anchor="same-device" title="Same Device Authentication"><t>TODO</t></section><section anchor="cross-device" title="Cross Device Authentication"><t>TODO</t></section><section title="Identity Association"><t>TODO</t></section><section title="Updating Identity Association"><t>TODO</t></section><section title="Disabling Site Login"><t>TODO</t></section><section title="Re-Enabling Site Login"><t>TODO</t></section></section><section anchor="acknowledgements" title="Acknowledgements"><t>TODO: Acknowledge Steve and the newsgroup...</t></section><section anchor="contributors" title="Contributors"><t>TODO: Acknowledge contributors to this text, if they are not included as authors or editors...</t></section><section anchor="IANA" title="IANA Considerations"><t>TODO</t></section><section anchor="Security" title="Security Considerations"><t>As SQRL aims to protect a single identity that is ultimately used to authenticate a user everywhere, the security of this identity is paramount. Further, users must face many of the same security issues as with traditional methods of authentication.</t><t>It is important to consider the following attack goals:</t><t>1. Session hijacking</t><t>2. Site credential theft</t><t>3. Association of SQRL identity to site account</t><t>4. Master key theft</t><t>5. Breaking of pseudonymous nature of SQRL authentication (association of SQRL identities on various sites)</t><section title="Phishing"><t>One well-known attack mode is where the user is invited to click on a link appearing to go to a legitimate site, but is in reality directed to an attacker's server.</t><t>One common method of this is a look-alike link. For example, a user believing he is going to example.com is in reality going to examp1e.com (the lowercase "l" is replaced with a numeral "1"). A historical example is "tvvitter.com" (the letter "v" twice instead of a "w").</t><t>Another method is to use a malformed URL to misdirect a user. For example, this link:</t><t>https://www.amazon.com@%67%72%63.%63%6f%6d/</t><t>at first glance appears to be a link to Amazon, but in reality takes the user to grc.com. In reality, the attacker would substitute the name of his phishing site and most users might be fooled entirely.</t><t>The phishing site is generally set up to look and work exactly the way the real site works, at least up until the point where the attacker has stolen the intended data.</t><t>Phishing attacks where the goal is to obtain authentication credentials are entirely foiled by SQRL. Since SQRL uses the domain name as the basis for authentication, it will create completely different identity keys. The SSPK the attacker gets will be a public key specifically for his attack site, useless to him for obtaining access to the real site.</t><t>However, the attacker may have other goals. If the attacker can successfully mimic an e-commerce site such as Amazon or a financial site such as PayPal, the user could be tricked into entering account data such as a credit card number. The real domain name is displayed to the user before authentication, giving him the opportunity to realize he is being fooled.</t><t>Many phishing attacks are pass-through attacks, where the phishing site acts as an active Man-In-The-Middle. It obtains the genuine page from the real site and passes it along to the user, receiving the user's responses and passing them back to the site. In the case of <xref target="same-device">same-device authentication</xref>, the client will be warned of an IP mismatch, and CPS will redirect the browser to a safe page on the real site. No such protections exist for <xref target="cross-device">cross-device authentication</xref>, but this is only used in the case of untrusted devices where the user will probably be typing in the domain name manually.</t><t>The attacker can get around SQRL's protections with DNS spoofing, where the device's DNS addresses are altered, entries are added to the hosts file, or otherwise made to redirect a host name to an incorrect address, generally the phishing site controlled by the attacker. In such a case, SQRL would be fooled (as would anything else on the compromised device).</t><t>However, cross-device authentication would foil this, as the user would be using a smartphone or other trusted device that would be doing its own DNS lookup. Local authentication should take place only on trusted devices. DNS could only be spoofed on these devices using malware, but malware can compromise any security feature.</t><t>A client developer could also foil such an attack by providing its own internal DNS resolver, bypassing the attacker's spoofing. However, such a feature may not be desired on enterprise networks running their own internal DNS systems, so it should be an option the user can turn off.</t></section><section title="Shoulder-Surfing"><t>Shoulder-surfing is when an attacker reads or scans the display, keyboard, and other components of the target's device directly, allowing the attacker to see sensitive information, including information entered into forms.</t><t>In the context of SQRL, the danger is of an attacker scanning the QR code of a SQRL-enabled website. With good timing, the attacker could fool the user into thinking he's logged in as himself when in reality he's authenticated to an account controlled by the attacker. The attacker could then get anything the user enters into that web site, including credit card numbers and other sensitive information.</t><t>However, in such a case the user's authentication would fail as the nut is no longer valid. The SQRL client MUST deliver an error message to the user saying that the authentication has failed, and SHOULD advise the user of the dangers of continuing to use the web site, especially if the authentication has the appearance of having worked.</t><t>Care should be taken when authenticating to a website in a public area, or any other place where others could see the QR code, or watch the user type the Master Password on the keyboard. Keep in mind that these can be picked up using binoculars or seen on a CCTV camera.</t><t>It is absolutely crucial that a new SQRL identity NOT be created, and an existing one NOT be rekeyed, in such an area. Anyone who can resolve the screen and keyboard can get the Master Password AND the Rescue Code.</t></section><section title="Evil Router"><t>In this context, the router in consideration is the one connecting the user's LAN segment to the rest of the Internet. Home routers have been shown to be lacking in security, and even a well-supported router must be updated when new firmware versions are released, something most users aren't aware of.</t><t>It is also increasingly the case that users connect to Wi-Fi hotspots when travelling, relying on routers whose security they could not evaluate even if they knew to. Moreover, an attacker on the LAN segment could engage in ARP spoofing to make the attacker's own device the default gateway for the segment, forwarding the packets on to the true router but establishing himself as a Man-In-The-Middle.</t><t>Once an attacker gains control of the default gateway, he could engage in phishing and DNS spoofing attacks as described above. More significantly, he could insert himself into the TLS handshake and commit any number of attacks designed to compromise the security of TLS.</t><t>SQRL provides no means of defending the user against such an attack, however, at most the attacker will gain access to the specific login sessions the user makes while at that location.</t></section><section title="Server Compromise"><t>A server compromise can result in sensitive user data being obtained by the attacker without the user even logging in.</t><t>In the case of SQRL there is less critical data for the attacker to get. There are no passwords or other secrets sent to the server that have to be hashed and protected. The attacker can only get the SSPK, SUK, and VUK, which are useless to him.</t><t>If the attacker has gained access to more than one site, the SSPK would be different, meaning that the attacker could not correlate user data between websites (unless, of course, there was other identifying information in common such as an email address).</t><t>All the same, once authenticated the user is subject to all of the harms that can occur regardless of the form of authentication.</t></section><section title="CPU Flooding"><t>CPU flooding is where the attacker is able to cause one or more processes to run that take up significant CPU time. It also can happen without a malicious attacker, when a normal process starts running in the background.</t><t>With SQRL, this can be a vulnerability when running <xref target="algo-enscrypt">EnScrypt</xref> in Timer Mode. After 5 seconds (by default), the timer runs out, and the resulting key is used to encrypt the identity and the number of iterations recorded. If another process utilizes significant CPU clocks during this process, the total number of iterations will be lower than it would have, meaning that the Master Password has weaker protection against cracking.</t></section><section title="Evil Client"><t>An evil client is a maliciously-developed SQRL client. It may take the form of its own client, or it may mimic an existing and trusted SQRL client. It may enter the user's computer in the form of malware, hijacking the sqrl:// protocol as a new handler and attaching itself to the localhost:25519 port. If artfully done, the user would have no clue that a substitution has been made.</t><t>The consequences cannot be overstated. The evil client would be able to gain the unencrypted IMK on its very first use, allowing the attacker to be able to hijack ANY account on ANY website where the user has authenticated using SQRL.</t><t>Moreover, it could keep track of everywhere the user logs in and send to the attacker all of the user's accounts on banking, e-commerce, and other important websites. And although a user can rekey his identity, he would first have to understand that his identity has been compromised.</t><t>The absolute worst case scenario would be when a user uses an evil client to create or rekey his identity, which would give the attacker access to even the Rescue Code. All other possible security concerns pale to this.</t><t>SQRL mitigates this possibility by requiring (and advising) only that the user place his SQRL identity on trusted devices, using cross-device authentication on all other devices. However, this only limits the attack surface. In the past, fake versions of Firefox and other web browsers, fake Bitcoin wallets, and numerous others have been downloaded by users and even placed inside the trusted app stores for Android and iOS. A malicious SQRL app, sadly, is not out of the question.</t><t>This issue can be somewhat mitigated by requiring that SQRL apps be certified by trusted authorities. The reference implementation from GRC not only checks the certificate on every update, but checks the fingerprint on the DigiCert root certificate as well to help ensure that there was no improper substitution. However, the ultimate protection can only come from complete SQRL integration into web browsers and operating systems, which will refuse to let any other software hijack the sqrl:// protocol and eliminate the need for a localhost connection on port 25519.</t></section></section></middle><!--  *****BACK MATTER ***** --><back><!-- References split into informative and normative --><!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).--><references title="Normative References"><!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC2104;
      &RFC2119;
      &RFC2898;
      &RFC3548;
      &RFC3986;
      &RFC7914;
      &RFC8031;
      &RFC8032;
      <reference anchor="FIPS.180-4.2015"><front><title>Secure Hash Standard</title><author><organization>National Institute of Standards and Technology</organization></author><date year="2015" month="August"/></front></reference>
      <reference anchor="NIST.800-38D"><front><title>NIST Special Publication 800-38D: Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC.</title><author initials="M." surname="Dworkin"><organization>U.S. National Institute of Standards and Technology</organization></author><date month="November" year="2007"/></front></reference>
    </references><references title="Informative References">
      &RFC4868;
      <reference anchor="Shamir"><front><title>How to share a secret</title><author initials="A." surname="Shamir"/><date month="November" year="1979"/></front><seriesInfo name="DOI" value="10.1145/359168.359176"/></reference>
      <reference anchor="Klyubin" target="https://android-developers.googleblog.com/2013/08/some-securerandom-thoughts.html"><front><title>Some SecureRandom Thoughts</title><author initials="A." surname="Klyubin">
          </author><date month="August" year="2013"/></front></reference>
    </references><section title="Recommendations and Best Practices"><section anchor="app-client" title="For Clients"><t>TODO</t></section><section anchor="app-server" title="For Servers"><t>TODO</t></section><section anchor="app-user" title="For Users"><t>Disclaimer: None of this is intended to be any sort of legal advice, or indeed any guarantee that problems involving SQRL clients and identities will be minimized. They are designed to apply to most SQRL users in most situations most of the time. It should be up to each individual's discretion to determine whether or not particular recommendations make sense to their situation.</t><section title="Master Password"><t>Traditionally, security experts have advised having unique passwords for every resource. The reason why is so that one resource being compromised will not threaten others. However, in the case of a single SQRL identity copied to multiple devices, a compromise of any of these identities would give an attacker full access to all SQRL-enabled logins, so the user gains nothing from protecting his SQRL identity on different devices with different passwords. But when users are asked to create different passwords, they generally pick weaker, formulaic passwords that are easier to remember.</t><t>For this reason, it makes sense to have a single strong password protecting all copies of the user's SQRL identity.</t></section><section title="Identity Backup"><t>It is crucial that the user not lose his or her identity, as that would lock him out of any and all needed resources. Keeping a secure backup is essential.</t><t>SQRL clients do not distinguish between exporting and backing up an identity, whether done by file, QR code, or text. But conceptually, exporting an identity is done with the intent to import it into another client in a timely manner. Therefore, exporting generally includes the identity encrypted with the Master Password.</t><t>Backups, on the other hand, are intended for longer-term storage. The encryption on them therefore needs to be more secure than perhaps will be the case with the user's Master Password, which may be forgotten in the interim anyway. Therefore, when making a backup of an identity, it should be made without the Master Password, containing only a copy of the encrypted IUK from which the identity can be regenerated. The user would therefore need the Rescue Code to restore the backup.</t><t>Note that text backup MUST NOT be exported without the Master Password.</t></section><section title="Disaster Recovery"><t>A user putting together his Last Will and Testament will want the executor(s) of his estate to be able to easily access all important assets. Since probate attorneys consider the security of all of this information to be paramount, it is recommended that they be given a hard copy of the SQRL client, exported without password, using the "data entry" method. The Rescue Code must also be included. The information must be updated whenever the user creates a new SQRL identity or rekeys an existing one.</t><t>If the use of a probate attorney isn't desirable (e.g., the user lives in a country with no recognition of attorney-client privilege), SQRL's "data entry" export and the associated Rescue Code could be distributed through the person's heirs via <xref target="Shamir">Shamir's Secret Sharing.</xref></t></section></section></section><section anchor="app-shortpass" title="The Optional ShortPass Feature"><t>TODO</t></section><section anchor="app-entropy" title="Harvesting Entropy"><t>Secure cryptographic systems depend on the ability to create quality random numbers, and SQRL is no different in this regard. SQRL's needs are meager compared to many other functions and protocols, but critical.</t><t>The use of a pseudo-random function to generate random numbers is only as good as the entropy it is seeded with. As RFC4086 points out, a hacker may find it easier to reproduce the environment a PRF was running in when it produced the secret quantities than to make blind guesses through the search space. [RFC4086]</t><t>Optimally, the numbers used for seeding cryptographic functions such as Curve25519 should be truly random, but what constitutes "truly random" is regarded as much philosophy as computer science. However, a good working definition of "truly random" is one where the amount of entropy in a number is equal to its length; e.g., a 256-bit number that contains 256 bits of entropy.</t><t>Unfortunately, determining the amount of entropy in an information stream is tricky at best. But entropy is never reduced as more information is added; even weak sources of entropy, when added together, can produce sufficient entropy. For that reason, none of the data collected during entropy harvesting should be discarded.</t><t>The method recommended by SQRL is to harvest as much entropy as possible from as many uncorrelated sources as possible in the time available, and run the data stream through SHA-256 or SHA-512, depending on how much randomness is needed. The Secure Hashing Algorithm should change half the bits of the output when just a single bit of the input is changed, so the entropy should be preserved up to the length of the resulting hash. The technique, then, is to hash an amount of data where the entropy content almost certainly far exceeds 256 or 512 bits. These amounts are fairly trivial.</t><t>For more about entropy harvesting, see RFC4086.</t><section title="Entropy Sources"><t>Sources of entropy vary greatly depending on the hardware, operating system, and other aspects of the client device.</t><section title="Operating System"><t>All operating systems have a source of randomness available (e.g., /dev/random on UNIX-like systems), but developers should think twice before relying solely on these. Flaws and backdoors could result in a false sense of security. For example, in 2013 a flaw in Android's SecureRandom function made wallets generated on those devices vulnerable to remote hacking and the theft of funds, even without access to the device. See <xref target="Klyubin"/></t><t>Developers should also be advised that many of these use some of the same techniques described below, meaning that utilizing the same technique might not result in as much entropy as estimated.</t></section><section title="Hardware"><t>Hardware sources can be very effective at harvesting entropy, but care must be taken to make sure that they exist on a particular implementation, and that the hardware hasn't failed in some way.</t><t>The system clock has traditionally been used as a source of randomness, although it must be considered that users are more likely to generate the random numbers at some times of the day than others. Subseconds provide the greatest entropy here.</t><t>Some systems come with embedded hardware that produce noise specifically for the purpose of seeding PRFs.</t><t>Wireless networking devices can be polled for signal strength and other data.</t><t>Processor statistics can be a significant source, such as cache hits/misses and other low-level system counters, voltage, fan speed, and thermal data.</t><t>Sound from a microphone could be a source of high-quality entropy in a typical room with air conditioning, fans, and other source of noise, as well as interference on the sound channel. In such a case, a fraction of a second--less than two hundredths--would be sufficient, but as there is no guarantee longer periods should be considered.</t><t>One or two frames from a camera can likewise be a source of high-entropy noise because of the sensor, which is especially the case if the SQRL client can set the camera's ISO to a high number. Most cell phones in particular have cameras that generate sufficient noise in the low-order bits. A single 640x480 frame would likely be sufficient for SQRL's purposes. Care must be taken to ensure the client is getting the raw camera data, not compressed data which may have much of the noise removed.</t><t>Free bytes of memory and storage space can vary quite a bit, adding a not insignificant amount of entropy.</t><t>Network statistics, such as packet arrival time, can be effective, but only if it can be ensured that these are not subject to manipulation.</t></section><section title="User"><t>The user can provide a good measure of entropy, either directly by the client engaging the user, or indirectly.</t><t>Examining mouse movements or keyboard strokes can be a source of entropy, although how much is a matter of some debate.</t><t>Accelerometer data on cell phones and other such devices can pick up minute movements of the user's hand, even if the user is trying to hold it steady.</t></section></section></section></back></rfc>
