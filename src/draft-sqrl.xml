<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. --><!ENTITY RFC2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3548 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3548.xml">
<!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4868 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4868.xml">
<!ENTITY RFC7914 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7914.xml">
<!ENTITY RFC8031 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8031.xml">
<!ENTITY RFC8032 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8032.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-sqrl-working"><!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" --><!-- ***** FRONT MATTER ***** --><front><!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters --><title abbrev="SQRL">Secure Quick Reliable Login (SQRL), an Authentication and Identity Management Framework</title><!-- add 'role="editor"' below for the editors if appropriate --><!-- Another author who claims to be an editor --><author fullname="Adam Comley" initials="A.C." role="editor" surname="Comley"><address><postal><street/><!-- Reorder these if your country does things differently --><city/><region/><code/><country/></postal><email>adam@novators.net</email><!-- uri and facsimile elements may also be added --></address></author><date month="February" year="2018"/><!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. --><!-- Meta-data Declarations --><area>General</area><workgroup>Internet Engineering Task Force</workgroup><!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. --><keyword>sqrl</keyword><!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. --><abstract><t>
        Secure Quick Reliable Login (SQRL) is an authentication method and 
        identity management framework.  It enables a user to create and manage
        a single, lifetime identity.  That identity will allow the user to 
        securely authenticate with any SQRL enabled server without relying on 
        a third party or disclosing personally identifiable information.
      </t><t>
        SQRL's identity management framework gives the user complete control 
        over their online identity, including provisions for recovering from
        the loss of their identity file or password and recovering from 
        potential security breaches.
      </t></abstract></front><middle><section title="Introduction"><t>
        Secure Quick Reliable Login (SQRL) is an authentication method and 
        identity management framework with the following features:
        <list style="hanging" hangIndent="3"><t hangText="Secure"><vspace/>
            Through a series of cryptographic signatures, the user can prove 
            their identity without disclosing any information that would allow 
            that identity to be compromised.
          </t><t hangText="Global Password"><vspace/>
            The user only has to remember a single password, which is used to 
            locally decrypt their identity during SQRL authentication.  Since 
            the user no longer has to remember a unique password for each site, 
            this one global password can be very strong.  This strong password 
            combined with strong encryption makes it infeasible for even a 
            state level actor to compromise the user's identity.
          </t><t hangText="Anonymous"><vspace/>
            SQRL authentication is anonymous, in that it only provides a 
            secure, site-specific token to the server.  This token cannot be 
            directly linked to a user's account at any other server, and 
            provides no personally identifiable information.
          </t><t hangText="No Third Party"><vspace/>
            The user's identity cannot be compromised by a security breach at 
            a third party authentication provider, protecting it from both 
            hackers and overreaching authorities.
          </t><t hangText="User Controlled, Lifetime Identity"><vspace/>
            SQRL provides an identity management framework which allows the 
            user to maintain complete control of their identity.  Even in the 
            event that their password is compromised, the user retains the 
            ability to retake control of their identity and lock the attacker 
            out.  Automated rekeying means that the user can maintain a single 
            SQRL identity indefinately, even after a compromise
          </t><t hangText="Offline Identity Backup"><vspace/>
            Since SQRL identities are intended to last a lifetime, and there 
            is no third party that can help the user recover their identity if 
            they forget their password, SQRL includes an offline backup 
            mechanism.  The user can print out or write down their encrypted 
            identity, along with a secure rescue code, that will allow the user 
            to recover from a forgotten password.
          </t><t hangText="Out Of Band Authentication Option"><vspace/>
            With SQRL, the user can safely authenticate a session on public or 
            potentially compromised systems by using a second, trusted device 
            to perform the authentication.  The user just has to scan a QR code 
            with their trusted mobile device to begin authentication.
          </t></list>
      </t><section title="Requirements Language"><t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in 
        <xref target="RFC2119">RFC 2119</xref>.</t></section><section title="Definitions"><t>TODO</t></section></section><section title="Algorithms"><t>TODO</t><section title="Standard Algorithms"><t>The following standard algorithms are used in this document:
          <list style="symbols"><t><xref target="NIST.800-38D">AES-GCM</xref></t><t>
              base64url: URL safe base64 encoding, as defined in Section 4 of 
              <xref target="RFC3548"/>, without padding.
            </t><t><xref target="RFC8031">Curve25519</xref></t><t><xref target="RFC8032">Ed25519</xref></t><t><xref target="RFC2104">HMAC</xref></t><t><xref target="RFC4868">HMAC-SHA256</xref></t><t><xref target="RFC7914">scrypt</xref></t><t><xref target="FIPS.180-4.2015">SHA-256</xref></t><t>
              urlencode: Percent-Encoding as defined in Section 2.1 of 
              <xref target="RFC3986"/>.
            </t></list>
        </t></section><section anchor="algo-b56c" title="base56check"><t>
          base56check encoding allows the backup of SQRL identities to a 
          textual form.  It:
          <list style="symbols"><t>Accepts an arbitrarily sized payload.</t><t>
              Uses a set of 56 alphanumeric symbols chosen to be easily 
              distinguishable in any font.
            </t><t>
              Ignores invalid characters and white space to allow readable 
              formatting.
            </t><t>
              Designed to be printed 20 characters per line, in 5 space 
              separated groups of 4 characters for readability.
            </t><t>
              Includes a check character at the end of each line to catch 
              errors while the user is typing.
            </t></list>
          The chosen alphabet is:
        </t><figure><artwork><![CDATA[
23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz
        ]]></artwork></figure><section title="Encoding"><t>
            To encode a series of bytes to base56check, treat the source bytes 
            as a single, large, little-endian number and convert using the 
            normal mathematical steps:
            <list style="format %d." counter="b56-encode-counter"><t>Divide SOURCE by 56 to yield SOURCE and REMAINDER.</t><t>
                Append the character in ALPHABET at position REMAINDER to the 
                BASE string.
              </t><t>Repeat from step 1, until SOURCE is zero.</t></list>
            Now, with our converted BASE string, we can calculate the check 
            digits and produce the final output.
            <list style="format %d." counter="b56-encode-counter"><t>
                Split BASE into 19 character CHUNKS (the final chunk may be 
                smaller).
              </t><t>
                For each CHUNK:
                <list style="letters"><t>Append a single byte zero-based CHUNK-NUMBER to the CHUNK.</t><t>Perform a SHA-256 hash on the CHUNK, yielding HASH.</t><t>
                    Treating HASH as a single little-endian number, divide 
                    HASH by 56 to obtain REMAINDER.
                  </t><t>
                    Replace the last character in CHUNK with the character in 
                    ALPHABET at position REMAINDER.
                  </t><t>Append the CHUNK to OUTPUT.</t></list>
              </t></list>
            OUTPUT can then be formatted as desired.  The recommended 
            formatting is 20 characters per line in space-separated groups of 
            4 characters each.  This format is easy for humans to read and type, 
            and allows error checking for each line of input.
          </t></section><section title="Validation"><t>
            base56check is designed to provide periodic error checking and 
            feedback to the user as they are typing.  To perform this validation:
            <list style="numbers"><t>Remove any characters from INPUT that are invalid (not included in ALPHABET).</t><t>Split INPUT into 20 character CHUNKS (the final chunk may be smaller).</t><t>For each CHUNK:
                <list style="letters"><t>Store the last character from CHUNK as CHECK.</t><t>Replace the last character in CHUNK with a single byte zero-based CHUNK-NUMBER.</t><t>Perform a SHA-256 hash on the CHUNK, yielding HASH.</t><t>Treating HASH as a single little-endian number, divide HASH by 56 to obtain REMAINDER.</t><t>Compare CHECK with the character from ALPHABET at position REMAINDER.</t><t>If comparison passes (is equal), continue.  Otherwise, there is an error in this CHUNK.</t></list>
              </t></list>
          </t></section><section title="Decoding"><t>
            Decoding base56check is similarly straight-forward:
            <list style="numbers"><t>
                Start with an empty BASE string and an zero OUTPUT buffer, to be 
                treated as a single, large, little-endian number.
              </t><t>
                Perform the base56check validation as described above, appending 
                all but the last character of each validated CHUNK to the 
                BASE string.
              </t><t>If any chunk fails validation, abort.</t><t>For each CHARACTER in BASE, from right to left:
                <list style="letters"><t>Multiply OUTPUT by 56.</t><t>Lookup the INDEX of CHARACTER in ALPHABET.</t><t>Add INDEX to OUTPUT.</t></list>
              </t></list>
          </t></section></section><section anchor="algo-enhash" title="EnHash"><figure><preamble>
            EnHash is an iterated hash used to derive a 256 bit key from 
            another 256 bit key.  It is performed by chaining 16 iterations 
            of SHA-256, with each iteration's output XORed to produce the 
            final output as follows:
          </preamble><artwork><![CDATA[
function EnHash ( input := 32 byte key )
{
  output := 32 byte buffer;

  set output to all NULL (0) bytes;

  repeat {
    input = SHA256( input );
    output = output XOR input;
  } 16 times;

  return output;
}
          ]]></artwork></figure></section><section anchor="algo-enscrypt" title="EnScrypt"><t>
          EnScrypt is an iterative construct based on the scrypt password based 
          key derivation function.  It hardens scrypt by allowing for extended 
          processing time.  The following parameters are used for the scrypt 
          function:
        </t><texttable anchor="table_enscrypt_parameters" title="scrypt parameters"><ttcol>dkLen</ttcol><ttcol>N</ttcol><ttcol>r</ttcol><ttcol>p</ttcol><c>32</c><c>512 (1&lt;&lt;9)</c><c>256</c><c>1</c></texttable><t>
          In this document, we may refer to an additional parameter, "n-factor" or
          just "n".  This is simply a shorthand way of storing the N parameter.
          N is derived from n as follows:
          <figure><artwork><![CDATA[
N = (1 << n);
          ]]></artwork></figure>
        </t><t>
          Enscrypt is performed by calling scrypt in multiple rounds, with each 
          successive round accepting the previous round's output as its salt.  
          The final output is the XOR of each round's scrypt result.
        </t><texttable anchor="table_enscrypt_rounds" title="EnScrypt Rounds"><ttcol>Round #</ttcol><ttcol>let salt[n] = </ttcol><ttcol>let out = </ttcol><c>1</c><c>scrypt( password, salt )</c><c>salt[1]</c><c>2</c><c>scrypt( password, salt[1] )</c><c>salt[1] XOR salt[2]</c><c>n</c><c>scrypt( password, salt[n-1] )</c><c>salt[n-1] XOR salt[n]</c></texttable><t>
          EnScrypt can operate in two different modes, the only difference 
          being when the calculation is stopped.
          <list style="hanging" hangIndent="3"><t hangText="Counter Mode:"><vspace/>
              Stops after a predefined number of iterations.
            </t><t hangText="Timer Mode:"><vspace/>
              Stops after a desired amount of time has passed.
            </t></list>
        </t></section></section><section title="Cryptographic Keys, Secrets, and Passwords"><t>
        SQRL uses a wide variety of secrets in various operations.
      </t><section anchor="secret-class-a" title="Class A Secrets"><t>
          Class A secrets are absolutely critical to protecting a user's 
          identity.  A compromised Class A secret may result in the user's 
          complete loss of control of the identity, with no recourse available.  
          Due to their highly sensitive nature, the following precautions are 
          REQUIRED when dealing with Class A secrets:
          <list style="symbols"><t>
              The secret MUST be generated using the highest quality entropy 
              source available to the client.  See <xref target="app-entropy"/> 
              for recommendations.
            </t><t>
              The client MUST prevent the secret from being written to 
              non-volatile memory in plaintext form, including being swapped to 
              disk, by any means possible.
            </t><t>
              The plaintext secret MUST be securely wiped from RAM as soon as 
              it is no longer needed.
            </t><t>
              If the secret is to be stored, it MUST be stored in an offline 
              format (printed), OR encrypted using a Class A key.
            </t><t>
              The secret SHOULD NOT be transmitted over the network in any form, 
              and MUST NOT be transmitted unencrypted.
            </t></list>
        </t><section title="Identity Unlock Key (IUK)"><figure><artwork><![CDATA[
IUK = RandomBytes( 32 );]]></artwork></figure><t>
            The IUK is a Class A 256 bit high entropy random number that 
            represents a user's identity.  All other identifying keys are 
            derived from this one.  After identity creation, this key is only 
            used in emergency situations, such as re-keying an identity in the 
            event of a possible compromise.
          </t></section><section title="Unlock Request Signing Key (URSK)"><figure><artwork><![CDATA[
URSK = curve25519_key_agreement( SUK, curve25519_private_key( IUK ));]]></artwork></figure><t>
            Used by the client to update the identity association on a server, 
            the URSK is derived from the SUK and IUK.
          </t></section><section title="Rescue Code (RC)"><t>
            The Rescue Code is a Class A, computer generated, high entropy 
            passcode consisting of 24 numeric digits.  The client SHOULD
            encourage the user to store the Rescue Code in an offline format 
            (printed or written).
          </t></section><section title="Password Derived Keys"><t>
            Several keys are generated from user input.  Both the user supplied 
            passwords and the derived keys are to be treated as Class A secrets.  
            Since these are expected to be low entropy, they must be processed 
            through EnScrypt (<xref target="algo-enscrypt"/>).  When generating 
            derived keys, EnScrypt MUST be used in timer mode with a minimum 
            duration of 1 second.  The table below lists RECOMMENDED durations 
            for EnScrypt key generation:
          </t><texttable anchor="table_pw_derived_keys" title="Password Derived Keys and Recommended EnScrypt Times"><ttcol>Key</ttcol><ttcol>Abbreviation</ttcol><ttcol>EnScrypt Time</ttcol><c>Password Derived Key</c><c>PWDK</c><c>5 seconds</c><c>Short Password Derived Key</c><c>SPDK</c><c>1 second</c><c>Rescue Code Derived Key</c><c>RCDK</c><c>60 seconds</c></texttable><t>
            Clients MAY allow the user to specify the EnScrypt time for the PWDK, 
            as long as that timer is at least 1 second.  The RCDK is used so 
            rarely, and is so important to protect, that 60 seconds should not 
            cause an undue burden on the user.  
          </t><t>
            When re-generating derived keys, EnScrypt is used in counter mode 
            with the iteration count from the original generation operation.
          </t></section></section><section anchor="secret-class-b" title="Class B Secrets"><t>
          Class B secrets are used often, and have less strict security 
          requirements.  A compromised Class B secret may result in an attacker 
          temporarily gaining the ability to impersonate the user to any server,
          but the user can regain control of their identity by rekeying followed 
          by authenticating with each affected server.  The following precautions 
          are REQUIRED when dealing with Class B secrets:
          <list style="symbols"><t>
              The client MUST prevent the secret from being written to non-volatile 
              memory in plaintext form, including being swapped to disk, by any 
              means possible.
            </t><t>
              The plaintext secret MUST be securely wiped from RAM as soon as it 
              is no longer needed.
            </t><t>
              If the secret is to be stored, it MUST be stored in an encrypted 
              form.
            </t><t>
              The secret SHOULD NOT be transmitted over the network in any form, 
              and MUST NOT be transmitted unencrypted.
            </t></list>
        </t><section title="Previous Identity Unlock Key (PIUK)"><t>
            A PIUK is an IUK that is no longer in active use.  It has been 
            replaced by a newly generated IUK, and requires less strict 
            protection.
          </t></section><section title="Identity Master Key (IMK)"><figure><artwork><![CDATA[
IMK = EnHash( IUK );]]></artwork></figure><t>
            This Class B ) key acts as a proxy for the IUK during normal SQRL 
            operation.  It is used to generate the unique keys that each site 
            associates with the user.  The IMK is derived from the IUK using 
            the EnHash (<xref target="algo-enhash"/>) function.
          </t></section><section title="Identity Lock Key (ILK)"><figure><artwork><![CDATA[
ILK = curve25519_public_key( curve25519_private_key( IUK ));]]></artwork></figure><t>
            The (modified) IUK and ILK together form a Curve25519 key pair.
          </t></section><section title="Site Specific Secret Key (SSSK)"><figure><artwork><![CDATA[
SSSK = HMAC-SHA256( IMK, Realm );]]></artwork></figure><t>
            The Site Specific Secret Key is generated from the IMK and the 
            Realm (<xref target="section-realm"/>).
          </t></section><section title="Random Lock Key (RLK)"><figure><artwork><![CDATA[
RLK = curve25519_private_key( RandomBytes( 32 ));]]></artwork></figure><t>
            The RLK is generated randomly when the client associates with a 
            new server.
          </t></section></section><section anchor="secret-class-c" title="Class C (Public) Keys"><t>
          Class C keys are not required to be kept secret.
        </t><section title="Site Specific Public Key (SSPK)"><figure><artwork><![CDATA[
SSPK = ed25519_public_key( SSSK );]]></artwork></figure><t>
            The Site Specific Public Key (SSPK) is the public counterpart to 
            the SSSK.
          </t></section><section title="Server Unlock Key (SUK)"><figure><artwork><![CDATA[
SUK = curve25519_public_key( RLK );]]></artwork></figure><t>
            Created during identity association, the SUK is the public 
            counterpart of the RLK.
          </t></section><section title="Verify Unlock Key (VUK)"><figure><artwork><![CDATA[
VUK = ed25519_public_key( curve25519_key_agreement( ILK, RLK ));]]></artwork></figure><t>
            Generated during identity association, and stored only on the 
            server, the VUK is the public key used to verify the client's 
            URSK.
          </t></section></section></section><section title="Identity Management"><section title="Identity Lifecycle"><t>
          TODO
        </t></section><section title="Identity Creation"><t>TODO</t></section><section title="User Options"><t>
          Several user options are available which will affect the operation
          of compatible SQRL clients:
          <list style="hanging" hangIndent="3"><t hangText="ShortPass Length:"><vspace/>
              The number of characters from the user's password to use as the
              ShortPass.  Clients that implement ShortPass MUST honor the user's
              choice here.  Valid values are 0 to 255.  A value of 0 disables the
              ShortPass feature.
            </t><t hangText="EnScrypt Seconds:"><vspace/>
              The number of seconds to run EnScrypt when deriving the PWDK.  The
              RECOMMENDED default is 5 seconds.  The REQUIRED minimum is 1 second.
            </t><t hangText="Idle Timeout:"><vspace/>
              If the client implements ShortPass or holds the user's password or keys
              in memory in any form, and the 0x0080 option flag is set, it MUST 
              securely erase that memory after this many minutes of system idle time.
              Valid values are 1-65535.
            </t><t hangText="Option Flags:"><vspace/>
              The following binary flags turn on or off various user options:
            </t></list>
        </t><texttable title="User Option Flags"><ttcol>Flag</ttcol><ttcol>Description</ttcol><c>0x0001</c><c>Check for updates:  Gives the client permission to periodically check for updates.</c><c>0x0002</c><c>Update Automatically:  Requests that the client automatically update itself when a new version is available.</c><c>0x0004</c><c>Request SQRL only:  Requests that servers disable other means of authentication and only allow SQRL.</c><c>0x0008</c><c>Request no bypass:  Requests that servers not allow non-SQRL account recovery options.</c><c>0x0010</c><c>Warn of possible MITM attack: The client will warn the user if their IP doesn't match the server's expectations.</c><c>0x0020</c><c>Clear ShortPass when screen blanks: The client will securely erase any ShortPass information when the screen saver is activated or the system is going to suspend / sleep modes.</c><c>0x0040</c><c>Clear ShortPass when changing users: The client will securely erase any ShortPass information when the system's active user changes.</c><c>0x0080</c><c>Clear ShortPass after idle timer: The client will securely erase any ShortPass information after the system has been idle for an amount of time specified in the "Idle Timeout" option.</c><c>0x0100</c><c>Warn of non-CPS authentication: The client will warn the user before a non-CPS authentication is attempted.  This flag MUST default to on.</c></texttable></section><section title="Identity Storage"><t>
          Because SQRL identities are intended to last the user's lifetime, 
          the user needs to be able to move his identity between clients.
          Every SQRL client MUST be able to import from and export identities
          to this standard format, regardless of how they store the identity
          internally.
        </t><t>
          Because identities should be backed up offline (to printed paper),
          the storage format must be compact enough to reliably fit in a
          printed QR code, and short enough to not cause undue burden if
          the user has to type it in by hand.
        </t><t>
          Values stored in standard SQRL storage format MUST follow these rules:
          <list style="symbols"><t>All numeric values are unsigned.</t><t>
              Multibyte numeric values are stored in little endian byte order,
              with the least significant byte first.
            </t><t>
              String values are stored in natural order, first byte first.
            </t></list>
        </t><section title="Encoding"><t>
            Identities may be stored to file or optical (QR) code in binary
            format, or in base64url or base56check (<xref target="algo-b56c"/>) 
            encoded text.  Compatible clients MUST support at least one of 
            these standard encodings.
          </t><t>
            Identities stored in this standard format MUST include an 8 byte
            header identifying the encoding used for the remainder of the file,
            with a single exception:  Identities exported to text using base56check
            encoding do not include a header.  Instead, they are validated by
            the encoded check characters.  The header itself is not encoded,
            but indicates that everything following it will be.
          </t><texttable anchor="table-id-encoding" title="Storage Encodings and Headers"><ttcol>Encoding</ttcol><ttcol>Header (ASCII)</ttcol><c>binary</c><c>sqrldata</c><c>base64url</c><c>SQRLDATA</c><c>base56check</c><c/></texttable></section><section title="Storage Blocks"><t>
            A stored SQRL identity is composed of any number of blocks.  Each block
            begins with a four byte header identifying the total length of the block 
            and the type of data stored in the block.
          </t><texttable anchor="table-block-format" title="Storage Block Format"><ttcol>Field</ttcol><ttcol>Size (bytes)</ttcol><c>block length in bytes (n+4)</c><c>2</c><c>block type</c><c>2</c><c>block data</c><c>n</c></texttable><t>
            Standard block types are defined in the next section.  Clients MAY add
            their own block types to store additional information, but SHOULD
            consider types 0-255 as reserved for future official block types.
            Any client reading an identity that encouters a block type unknown to
            that client MUST simply ignore that block.
          </t></section><section title="Predefined Block Types"><section title="Block Type 1: Working Identity"><t>
              The type 1 block contains the user's encrypted IMK and ILK, as well as 
              user defined options.  The user options are in plain text, but MUST be 
              regarded as untrusted until authenticated through AES-GCM.  The type 1 
              block is formatted as follows:
            </t><texttable title="Type 1 Block"><ttcol>Field</ttcol><ttcol>Default</ttcol><ttcol align="right">Bytes</ttcol><c>Block Length</c><c>125</c><c>2</c><c>Block Type</c><c>1</c><c>2</c><c>AAD Length</c><c>45</c><c>2</c><c>AES-GCM IV</c><c/><c>12</c><c>EnScrypt Salt</c><c/><c>16</c><c>EnScrypt n-factor</c><c>9</c><c>1</c><c>EnScrypt Iteration Count</c><c/><c>4</c><c>User Option Flags</c><c>0x01F3</c><c>2</c><c>ShortPass Length</c><c>4</c><c>1</c><c>EnScrypt Seconds</c><c>5</c><c>1</c><c>Idle Timeout (minutes)</c><c>15</c><c>2</c><c>Encrypted IMK</c><c/><c>32</c><c>Encrypted ILK</c><c/><c>32</c><c>AES-GCM Verification Tag</c><c/><c>16</c></texttable><t>
              Constructing a type 1 block is relatively straight-forward:
              <list style="numbers"><t>Allocate a 125 byte buffer.</t><t>Populate the default values (or user chosen options).</t><t>Generate a random 12 byte initialization vector (IV) and store it in the buffer.</t><t>Generate a random 16 byte salt and store it in the buffer.</t><t>Use the salt to run EnScrypt on the user's password for the chosen amount of time (default 5 seconds) to obtain the encryption key.</t><t>Populate the EnScrypt iteration count in the buffer.</t><t>AES-GCM encrypt the IMK and ILK (64 bytes total) using the first "AAD Length" bytes of the buffer as AAD, the IV, and the generated encryption key.</t><t>Populate the ciphertext result and verification tag from AES-GCM.</t><t>Securely wipe the plaintext keys, encryption key, and password from memory if they are no longer needed.</t></list>
              If the client is updating a type 1 block, and the user's password hasn't changed, 
              clients SHOULD use the original salt and iteration count to re-encrypt the block.
            </t></section><section title="Block Type 2: Identity Unlock Key"><t>TODO</t></section><section title="Block Type 3: Previous Identities"><t>TODO</t></section></section></section><section title="Importing / Exporting an Identity"><t>TODO</t><section title="Binary File"><t>TODO</t></section><section title="Printed QR Code"><t>TODO</t></section><section title="Printed Text"><t>TODO</t></section></section><section title="Changing the User's Password"><t>TODO</t></section><section title="Identity Recovery"><t>TODO</t></section><section title="Re-Keying and Identity"><t>TODO</t></section></section><section title="Client-Server Protocol"><t>TODO</t><section title="Initiation of SQRL Authentication"><t>TODO</t><section title="The SQRL Scheme"><t>TODO</t></section><section title="QR Codes (Out of Band)"><t>TODO</t></section></section><section anchor="section-realm" title="The SQRL Realm (Domain)"><t>TODO</t></section><section title="Client to Server Requests"><t>TODO</t><section title="Protocol Version"><t>TODO</t></section><section title="Commands"><t>TODO</t></section><section title="Options"><t>TODO</t></section><section title="The server Value"><t>TODO</t></section><section title="The client Value"><t>TODO</t></section><section title="Client Keys"><t>TODO</t></section><section title="Client Signatures"><t>TODO</t></section><section title="Composing the Request"><t>TODO</t></section></section><section title="Server to Client Replies"><t>TODO</t><section title="Required Values"><t>TODO</t></section><section title="Optional Values"><t>TODO</t></section><section title="Additional Values"><t>TODO</t></section><section title="Composing the Reply"><t>TODO</t></section></section></section><section title="Client-Server Interactions"><t>TODO</t><section title="Same Device Authentication"><t>TODO</t></section><section title="Cross Device Authentication"><t>TODO</t></section><section title="Identity Association"><t>TODO</t></section><section title="Updating Identity Association"><t>TODO</t></section><section title="Disabling Site Login"><t>TODO</t></section><section title="Re-Enabling Site Login"><t>TODO</t></section></section><section anchor="IANA" title="IANA Considerations"><t>TODO</t></section><section anchor="Security" title="Security Considerations"><t>TODO</t></section></middle><!--  *****BACK MATTER ***** --><back><!-- References split into informative and normative --><!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).--><references title="Normative References"><!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC2104;
      &RFC2119;
      &RFC3548;
      &RFC3986;
      &RFC7914;
      &RFC8031;
      &RFC8032;
      <reference anchor="FIPS.180-4.2015"><front><title>Secure Hash Standard</title><author><organization>National Institute of Standards and Technology</organization></author><date year="2015" month="August"/></front></reference>
      <reference anchor="NIST.800-38D"><front><title>NIST Special Publication 800-38D: Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC.</title><author initials="M." surname="Dworkin"><organization>U.S. National Institute of Standards and Technology</organization></author><date month="November" year="2007"/></front></reference>

    </references><references title="Informative References">
      &RFC4868;
    </references><section anchor="app-client" title="SQRL Client Best Practices"><t>TODO</t></section><section anchor="app-server" title="SQRL Server Best Practices"><t>TODO</t></section><section anchor="app-shortpass" title="ShortPass"><t>TODO</t></section><section anchor="app-entropy" title="Harvesting Entropy"><t>TODO</t></section></back></rfc>
