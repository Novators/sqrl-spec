<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. --><!ENTITY RFC2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2898 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2898.xml">
<!ENTITY RFC3548 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3548.xml">
<!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4868 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4868.xml">
<!ENTITY RFC7914 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7914.xml">
<!ENTITY RFC8031 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8031.xml">
<!ENTITY RFC8032 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8032.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-sqrl-working">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->
  <!-- ***** FRONT MATTER ***** -->
  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->
    <title abbrev="SQRL">Secure Quick Reliable Login (SQRL), an Authentication and Identity Management Framework</title>
    <!-- add 'role="editor"' below for the editors if appropriate -->
    <!-- Another author who claims to be an editor -->
    <author fullname="Adam Comley" initials="A.C." surname="Comley">
      <address>
        <postal>
          <street/>
          <!-- Reorder these if your country does things differently -->
          <city/>
          <region/>
          <code/>
          <country/>
        </postal>
        <email>adam@novators.net</email>
        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>
    <author fullname="Shane D. Killian" initials="S.D." surname="Killian">
      <address>
        <postal>
          <street/>
          <city/>
          <region/>
          <code/>
          <country/>
        </postal>
        <email>shane@shanekillian.org</email>
      </address>
    </author>
    <date month="February" year="2018"/>
    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
     in the current day and month for you. If the year is not the current one, it is 
     necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
     purpose of calculating the expiry date).  With drafts it is normally sufficient to 
     specify just the year. -->
    <!-- Meta-data Declarations -->
    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
     If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->
    <keyword>sqrl</keyword>
    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->
    <abstract>
      <t>Secure Quick Reliable Login (SQRL) is an application-level protocol for user authentication and identity management.  It enables a user to create and manage a single pseudonymous lifetime identity.  That identity will allow the user to securely authenticate with any SQRL enabled server without relying on a third party or disclosing personally identifiable information.</t>
      <t/>
      <t>It provides:<list style="symbols"><t>Unique pseudonymous identifiers for each site</t><t>Separation of identity management from account management</t><t>Strong anti-phishing protection</t><t>No shared secrets that can be exploited by bad actors</t><t>Out-of-band authentication for logging in on untrusted devices</t></list></t>
    </abstract>
  </front>
  <middle>
    <section title="Introduction">
      <section title="Purpose">
        <t>Secure Quick Reliable Login (SQRL) is an authentication method and identity management framework which gives the user complete control over their online identity, including provisions for recovering from the loss of their identity file or password and recovering from potential security breaches.</t>
      </section>
      <section title="Features">
        <t>
          <list style="hanging" hangIndent="3">
            <t hangText="Secure"><vspace/>
              Through a series of cryptographic signatures, the user can prove 
              their identity without disclosing any information that would allow 
              that identity to be compromised or their account hacked. SQRL also provides strong anti-phishing features.
            </t>
            <t hangText="Identity Management"><vspace/>
              SQRL separates and delineates the concepts of account and identity. SQRL provides a full identity lifecycle management framework which allows the user to maintain complete control of their identity, while leaving servers with complete control over account issues.  Even in the event of a compromise, the user retains the ability to retake control of their identity and lock the attacker out.  Automated rekeying means that the user can maintain a single SQRL identity indefinitely, even after a compromise.
            </t>
            <t hangText="Global Password"><vspace/>
              The user only has to remember a single password, which is used to 
              locally decrypt their identity during SQRL authentication.  Since 
              the user no longer has to remember a unique password for each site, 
              this one global password can be very strong.  This strong password 
              combined with strong encryption makes it infeasible for even a 
              state level actor to compromise the user's identity. (SQRL apps can alternately use other methods of protection such as biometrics when available on the host device.)
            </t>
            <t hangText="Pseudononymous"><vspace/>
              SQRL authentication is pseudonymous, in that it only provides a 
              secure, site-specific token to the server.  This token cannot be 
              directly linked to a user's account at any other server, and 
              provides no personally identifiable information.
            </t>
            <t hangText="No Shared Secrets"><vspace/>
              Passwords, time-based authenticators, and other authentication methods work through shared secrets. These secrets can conceivably be stolen by hackers or rogue employees and used to impersonate the user. SQRL does not operate through shared secrets, and even if the server's account database is stolen the attacker is not given any means to impersonate the user.
            </t>
            <t hangText="No Third Party"><vspace/>
              The user's identity cannot be compromised by a security breach at 
              a third party authentication provider, protecting it from both 
              hackers and overreaching authorities.
            </t>
            <t hangText="No Per-Site Settings"><vspace/>
              Unlike password managers, SQRL does not require any information about specific websites to be saved, preventing potential privacy issues stemming from information leaks as well as keeping its database size small.
            </t>
            <t hangText="Offline Identity Backup"><vspace/>
              Since SQRL identities are intended to last a lifetime, and there 
              is no third party that can help the user recover their identity if 
              they forget their password, SQRL includes an offline backup 
              mechanism.  The user can print out or write down their encrypted 
              identity, along with a secure Rescue Code, that will allow the user 
              to recover from a forgotten password.
            </t>
            <t hangText="Out Of Band Authentication Option"><vspace/>
              With SQRL, the user can safely authenticate a session on public or 
              potentially compromised systems by scanning a QR code 
              on a trusted mobile device containing their SQRL identity, without the need to expose that identity to the public system.
            </t>
          </list>
        </t>
      </section>
      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.</t>
      </section>
      <section title="Definitions">
        <t>
          <list style="hanging" hangIndent="3">
            <t hangText="Account"><vspace/>  Information on a user's services and permissions on a particular web site for purposes of facilitating access</t>
            <t hangText="Authentication"><vspace/>The process of verifying an identity and attaching it to an account</t>
            <t hangText="Backup"><vspace/>To externally save a user's Rescue Code-protected IUK via file, QR code, or text without saving the IMK</t>
            <t hangText="Client"><vspace/>The user component of SQRL</t>
            <t hangText="Export"><vspace/>To externally save a user's Rescue Code-protected IUK and password-protected IMK via file or QR code</t>
            <t hangText="Identity"><vspace/>A means of pseudonymously recognizing a user</t>
            <t hangText="Identity Lock"><vspace/>A method of locking a user's identity on various websites (generally out of fear the user's IMK may be compromised) for later unlocking with Rescue Code or rekeyed identity</t>
            <t anchor="IDK" hangText="IDK"><vspace/>IDentity Key: a secure, irreversible, and collision-resistant public key used to identify the user in a specific realm; unique to both the realm and the user's IMK</t>
            <t hangText="ILK"><vspace/>Identity Lock Key: public key counterpart to the IUK</t>
            <t hangText="IMK"><vspace/>Identity Master Key: A key derived from the IUK that is the basis of a user's identity for each realm</t>
            <t hangText="Import"><vspace/>To load an exported or backed up identity into a client</t>
            <t hangText="IUK"><vspace/>Identity Unlock Key: the master key from which all aspects of a user's identity are derived</t>
            <t hangText="Master Password"><vspace/>A password created by the user that is used to derive the encryption key for the user's IMK</t>
            <t hangText="Nut"><vspace/>A unique, unpredictable, cryptographically-strong string identifying the current session</t>
            <t hangText="Pseudonymous"><vspace/>Of a consistent and reliable means of verifying a user without having to obtain personal information</t>
            <t hangText="Realm"><vspace/>The basis for generating a unique identity key; generally the domain name, but additional data can be included (ref)</t>
            <t hangText="Rekey"><vspace/>To replace a potentially-compromised IMK</t>
            <t hangText="Rescue Code"><vspace/>A cryptographically-strong 24 decimal digit random number that is used to derive the encryption key for the user's IUK</t>
            <t hangText="RLK"><vspace/>Random Lock Key: generated randomly by a user for a new website and used as the basis of the Identity Lock system</t>
            <t hangText="Server"><vspace/>The backend component of SQRL that verifies a user identity and attaches it to an account</t>
            <t hangText="ShortPass"><vspace/>The first few characters (4 by default) of a user's Master Password; used to verify the user after the Master Password has been used to start a session</t>
            <t anchor="SUK" hangText="SUK"><vspace/>Server Unlock Key: public key counterpart to the RLK; sent by the user to the server on account creation and used to unlock an identity</t>
            <t target="VUK" hangText="VUK"><vspace/>Verify Unlock Key: public key counterpart to a Diffie-Hellman key generated by the RLK and the ILK; later used to verify an unlock request from the user made from the SUK and the user's IUK</t>
          </list>
        </t>
      </section>
    </section>
    <section title="Algorithms">
      <t>TODO</t>
      <section title="Standard Algorithms">
        <t>The following standard algorithms are used in this document:
          <list style="symbols"><t><xref target="NIST.800-38D">AES-GCM</xref></t><t>
              base64url: URL safe base64 encoding, as defined in Section 4 of 
              <xref target="RFC3548"/>, without padding.
            </t><t><xref target="RFC8031">Curve25519</xref></t><t><xref target="RFC8032">Ed25519</xref></t><t><xref target="RFC2104">HMAC</xref></t><t><xref target="RFC4868">HMAC-SHA256</xref></t><t><xref target="RFC2898">PBKDF2</xref></t><t><xref target="RFC7914">scrypt</xref></t><t><xref target="FIPS.180-4.2015">SHA-256</xref></t><t>
              urlencode: Percent-Encoding as defined in Section 2.1 of 
              <xref target="RFC3986"/>.
            </t></list>
        </t>
      </section>
      <section anchor="algo-b56c" title="base56check">
        <t>
          base56check encoding allows the backup of SQRL identities to a 
          textual form.  It:
          <list style="symbols"><t>Accepts an arbitrarily sized payload.</t><t>
              Uses a set of 56 alphanumeric symbols chosen to be easily 
              distinguishable in any font.
            </t><t>
              Ignores invalid characters and white space to allow readable 
              formatting.
            </t><t>
              Designed to be printed 20 characters per line, in 5 space 
              separated groups of 4 characters for readability.
            </t><t>
              Includes a check character at the end of each line to catch 
              errors while the user is typing with 98.2% accuracy.
            </t></list>
          The chosen alphabet is:
        </t>
        <figure>
          <artwork><![CDATA[
23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz
        ]]></artwork>
        </figure>
        <section title="Encoding">
          <t>
            To encode a series of bytes to base56check, treat the source bytes 
            as a single, large, little-endian number and convert using the 
            normal mathematical steps:
            <list style="format %d." counter="b56-encode-counter"><t>Calculate BASE_LENGTH:  ceil( SOURCE_LENGTH * 8.0 / log2(56))</t><t>Divide SOURCE by 56 to yield SOURCE and REMAINDER.</t><t>
                Append the character in ALPHABET at position REMAINDER to the 
                BASE string.
              </t><t>Repeat from step 1, until SOURCE is zero.</t><t>Append '2' (character in ALPHABET at position 0) to BASE until BASE is BASE_LENGTH bytes long.</t></list>
            Now, with our converted BASE string, we can calculate the check 
            digits and produce the final output.
            <list style="format %d." counter="b56-encode-counter"><t>
                Split BASE into 19 character CHUNKS (the final chunk may be 
                smaller).
              </t><t>
                For each CHUNK:
                <list style="letters"><t>Append a single byte zero-based CHUNK-NUMBER to the CHUNK.</t><t>Perform a SHA-256 hash on the CHUNK, yielding HASH.</t><t>
                    Treating HASH as a single little-endian number, divide 
                    HASH by 56 to obtain REMAINDER.
                  </t><t>
                    Replace the last character in CHUNK with the character in 
                    ALPHABET at position REMAINDER.
                  </t><t>Append the CHUNK to OUTPUT.</t></list>
              </t></list>
            OUTPUT can then be formatted as desired.  The RECOMMENDED 
            formatting is 20 characters per line in space-separated groups of 
            4 characters each.  This format is easy for humans to read and type, 
            and allows error checking for each line of input.
          </t>
        </section>
        <section title="Validation">
          <t>
            base56check is designed to provide periodic error checking and 
            feedback to the user as they are typing.  To perform this validation:
            <list style="numbers"><t>Remove any characters from INPUT that are invalid (not included in ALPHABET).</t><t>Split INPUT into 20 character CHUNKS (the final chunk may be smaller).</t><t>For each CHUNK:
                <list style="letters"><t>Store the last character from CHUNK as CHECK.</t><t>Replace the last character in CHUNK with a single byte zero-based CHUNK-NUMBER.</t><t>Perform a SHA-256 hash on the CHUNK, yielding HASH.</t><t>Treating HASH as a single little-endian number, divide HASH by 56 to obtain REMAINDER.</t><t>Compare CHECK with the character from ALPHABET at position REMAINDER.</t><t>If comparison passes (is equal), continue.  Otherwise, there is an error in this CHUNK.</t></list>
              </t></list>
          </t>
        </section>
        <section title="Decoding">
          <t>
            Decoding base56check is similarly straight-forward:
            <list style="numbers"><t>
                Start with an empty BASE string and an zero OUTPUT buffer, to be 
                treated as a single, large, little-endian number.
              </t><t>
                Perform the base56check validation as described above, appending 
                all but the last character of each validated CHUNK to the 
                BASE string.
              </t><t>If any chunk fails validation, abort.</t><t>For each CHARACTER in BASE, from right to left:
                <list style="letters"><t>Multiply OUTPUT by 56.</t><t>Lookup the INDEX of CHARACTER in ALPHABET.</t><t>Add INDEX to OUTPUT.</t></list>
              </t></list>
          </t>
        </section>
      </section>
      <section anchor="algo-enhash" title="EnHash">
        <figure>
          <preamble>
            EnHash is an iterated hash used to derive a 256 bit key from 
            another 256 bit key.  It is performed by chaining 16 iterations 
            of SHA-256, with each iteration's output XORed to produce the 
            final output as follows:
          </preamble>
          <artwork><![CDATA[
function EnHash ( input := 32 byte key )
{
  output := 32 byte buffer;

  set output to all NULL (0) bytes;

  repeat {
    input = SHA256( input );
    output = output XOR input;
  } 16 times;

  return output;
}
          ]]></artwork>
        </figure>
      </section>
      <section anchor="algo-enscrypt" title="EnScrypt">
        <t>
          EnScrypt is an implementation of PBKDF2 using scrypt as a PRF.  It hardens scrypt by allowing for extended 
          processing time while keeping memory requirements low but still effective.</t>
        <t>The following parameters are used for the scrypt           function:
        </t>
        <texttable anchor="table_enscrypt_parameters" title="scrypt parameters">
          <ttcol>dkLen</ttcol>
          <ttcol>N</ttcol>
          <ttcol>r</ttcol>
          <ttcol>p</ttcol>
          <c>32</c>
          <c>512 (1&lt;&lt;9)</c>
          <c>256</c>
          <c>1</c>
        </texttable>
        <t>
          In this document, we may refer to an additional parameter, "n-factor" or
          just "n".  This is simply a shorthand way of storing the N parameter.
          N is derived from n as follows:
          <figure><artwork><![CDATA[
N = (1 << n);
          ]]></artwork></figure>
        </t>
        <t>
          Enscrypt is performed by calling scrypt via multiple rounds of PBKDF2.
        </t>
        <t>
          EnScrypt can operate in two different modes, the only difference 
          being when the calculation is stopped.
          <list style="hanging" hangIndent="3"><t hangText="Counter Mode:"><vspace/>
              Stops after a predefined number of iterations.
            </t><t hangText="Timer Mode:"><vspace/>
              Stops after a desired amount of time has passed (5 seconds by default).
            </t></list>
        </t>
        <t>Timer Mode is used when creating an encryption key from a password. Successive rounds of PBKDF2 are computed until the specified time elapses. The result is used as the key to encrypt the identity, and the resulting number of iterations is saved with the identity file. Counter Mode is used to recreate this key and decrypt the identity.</t>
      </section>
    </section>
    <section title="Cryptographic Keys, Secrets, and Passwords">
      <t>
        SQRL uses a wide variety of secrets in various operations.
      </t>
      <section anchor="secret-class-a" title="Class A Secrets">
        <t>
          Class A secrets are absolutely critical to protecting a user's 
          identity.  A compromised Class A secret may result in the user's 
          complete loss of control of the identity, with no recourse available.  
          Due to their highly sensitive nature, the following precautions are 
          REQUIRED when dealing with Class A secrets:
          <list style="symbols"><t>
              The secret MUST be generated using the highest quality entropy 
              source available to the client.  See <xref target="app-entropy"/> 
              for recommendations.
            </t><t>
              The client MUST prevent the secret from being written to 
              non-volatile memory in plaintext form, including being swapped to 
              disk, by any means possible.
            </t><t>
              The plaintext secret MUST be securely wiped from RAM as soon as 
              it is no longer needed.
            </t><t>
              If the secret is to be stored, it MUST be stored in an offline 
              format (printed), OR encrypted using a Class A key.
            </t><t>
              The secret SHOULD NOT be transmitted over the network in any form, 
              and MUST NOT be transmitted unencrypted.
            </t></list>
        </t>
        <section title="Identity Unlock Key (IUK)">
          <figure>
            <artwork><![CDATA[
IUK = RandomBytes( 32 );]]></artwork>
          </figure>
          <t>
            The IUK is a Class A 256 bit high entropy random number that 
            represents a user's identity.  All other identifying keys are 
            derived from this one.  After identity creation, this key is only 
            used in emergency situations, such as rekeying an identity in the 
            event of a possible compromise.
          </t>
        </section>
        <section title="Unlock Request Signing Key (URSK)">
          <figure>
            <artwork><![CDATA[
URSK = curve25519_key_agreement( SUK, curve25519_private_key( IUK ));]]></artwork>
          </figure>
          <t>
            Used by the client to update the identity association on a server, 
            the URSK is derived from the SUK and IUK.
          </t>
        </section>
        <section title="Rescue Code (RC)">
          <t>
            The Rescue Code is a Class A, computer generated, high entropy 
            passcode consisting of 24 numeric digits.  The client SHOULD
            encourage the user to store the Rescue Code in an offline format 
            (printed or written).
          </t>
        </section>
        <section title="Password Derived Keys">
          <t>
            Several keys are generated from user input.  Both the user supplied 
            passwords and the derived keys are to be treated as Class A secrets.  
            Since these are expected to be low entropy, they must be processed 
            through EnScrypt (<xref target="algo-enscrypt"/>).  When generating 
            derived keys, EnScrypt MUST be used in timer mode with a minimum 
            duration of 1 second.  The table below lists RECOMMENDED durations 
            for EnScrypt key generation:
          </t>
          <texttable anchor="table_pw_derived_keys" title="Password Derived Keys and Recommended EnScrypt Times">
            <ttcol>Key</ttcol>
            <ttcol>Abbreviation</ttcol>
            <ttcol>EnScrypt Time</ttcol>
            <c>Password Derived Key</c>
            <c>PWDK</c>
            <c>5 seconds</c>
            <c>Short Password Derived Key</c>
            <c>SPDK</c>
            <c>1 second</c>
            <c>Rescue Code Derived Key</c>
            <c>RCDK</c>
            <c>60 seconds</c>
          </texttable>
          <t>
            Clients MAY allow the user to specify the EnScrypt time for the PWDK, 
            as long as that timer is at least 1 second.  The RCDK is used so 
            rarely, and is so important to protect, that 60 seconds should not 
            cause an undue burden on the user.  
          </t>
          <t>
            When re-generating derived keys, EnScrypt is used in counter mode 
            with the iteration count from the original generation operation.
          </t>
        </section>
      </section>
      <section anchor="secret-class-b" title="Class B Secrets">
        <t>
          Class B secrets are used often, and have less strict security 
          requirements.  A compromised Class B secret may result in an attacker 
          temporarily gaining the ability to impersonate the user to any server,
          but the user can regain control of their identity by rekeying followed 
          by authenticating with each affected server.  The following precautions 
          are REQUIRED when dealing with Class B secrets:
          <list style="symbols"><t>
              The client MUST prevent the secret from being written to non-volatile 
              memory in plaintext form, including being swapped to disk, by any 
              means possible.
            </t><t>
              The plaintext secret MUST be securely wiped from RAM as soon as it 
              is no longer needed.
            </t><t>
              If the secret is to be stored, it MUST be stored in an encrypted 
              form.
            </t><t>
              The secret SHOULD NOT be transmitted over the network in any form, 
              and MUST NOT be transmitted unencrypted.
            </t></list>
        </t>
        <section title="Previous Identity Unlock Key (PIUK)">
          <t>
            A PIUK is an IUK that is no longer in active use.  It has been 
            replaced by a newly generated IUK, and requires less strict 
            protection.
          </t>
        </section>
        <section title="Identity Master Key (IMK)">
          <figure>
            <artwork><![CDATA[
IMK = EnHash( IUK );]]></artwork>
          </figure>
          <t>
            This Class B key acts as a proxy for the IUK during normal SQRL 
            operation.  It is used to generate the unique keys that each site 
            associates with the user.  The IMK is derived from the IUK using 
            the EnHash (<xref target="algo-enhash"/>) function.
          </t>
        </section>
        <section title="Identity Lock Key (ILK)">
          <figure>
            <artwork><![CDATA[
ILK = curve25519_public_key( curve25519_private_key( IUK ));]]></artwork>
          </figure>
          <t>
            The (modified) IUK and ILK together form a Curve25519 key pair.
          </t>
        </section>
        <section anchor="SSSK" title="Site Specific Secret Key (SSSK)">
          <figure>
            <artwork><![CDATA[
SSSK = HMAC-SHA256( IMK, Realm );]]></artwork>
          </figure>
          <t>
            The Site Specific Secret Key is generated from the IMK and the 
            Realm (<xref target="section-realm"/>).
          </t>
        </section>
        <section title="Random Lock Key (RLK)">
          <figure>
            <artwork><![CDATA[
RLK = curve25519_private_key( RandomBytes( 32 ));]]></artwork>
          </figure>
          <t>
            The RLK is generated randomly when the client associates with a 
            new server.
          </t>
        </section>
      </section>
      <section anchor="secret-class-c" title="Class C (Public) Keys">
        <t>
          Class C keys are not required to be kept secret.
        </t>
        <section title="Site Specific Public Key (SSPK)">
          <figure>
            <artwork><![CDATA[
SSPK = ed25519_public_key( SSSK );]]></artwork>
          </figure>
          <t>
            The Site Specific Public Key (SSPK) is the public counterpart to 
            the SSSK.  It serves as the user's pseudonymous identity on the site.
          </t>
        </section>
        <section title="Server Unlock Key (SUK)">
          <figure>
            <artwork><![CDATA[
SUK = curve25519_public_key( RLK );]]></artwork>
          </figure>
          <t>
            Created during identity association, the SUK is the public 
            counterpart of the RLK.
          </t>
        </section>
        <section title="Verify Unlock Key (VUK)">
          <figure>
            <artwork><![CDATA[
VUK = ed25519_public_key( curve25519_key_agreement( ILK, RLK ));]]></artwork>
          </figure>
          <t>
            Generated during identity association, and stored only on the 
            server, the VUK is the public key used to verify the client's 
            URSK.
          </t>
        </section>
      </section>
    </section>
    <section title="Identity Management">
      <section title="Identity Lifecycle">
        <t>
          TODO
        </t>
      </section>
      <section anchor="user-options" title="User Options">
        <t>
          Several user options are available which will affect the operation
          of compatible SQRL clients:
          <list style="hanging" hangIndent="3"><t hangText="ShortPass Length:"><vspace/>
              The number of characters from the user's password to use as the
              ShortPass (<xref target="app-shortpass"/>).  Clients that implement ShortPass MUST honor the user's
              choice here.  Valid values are 0 to 255.  A value of 0 disables the
              ShortPass feature.
            </t><t hangText="EnScrypt Seconds:"><vspace/>
              The number of seconds to run EnScrypt when deriving the PWDK.  The
              RECOMMENDED default is 5 seconds.  The REQUIRED minimum is 1 second.
            </t><t hangText="Idle Timeout:"><vspace/>
              If the client implements ShortPass or holds the user's password or keys
              in memory in any form, and the 0x0080 option flag is set, it MUST 
              securely erase that memory after this many minutes of system idle time.
              Valid values are 1-65535.
            </t><t hangText="Option Flags:"><vspace/>
              The following binary flags turn on or off various user options:
            </t></list>
        </t>
        <texttable title="User Option Flags">
          <ttcol>Flag</ttcol>
          <ttcol>Description</ttcol>
          <c>0x0001</c>
          <c>Check for updates:  Gives the client permission to periodically check for updates.</c>
          <c>0x0002</c>
          <c>Update Automatically:  Requests that the client automatically update itself when a new version is available.</c>
          <c>0x0004</c>
          <c>Request SQRL only:  Requests that servers disable other means of authentication and only allow SQRL.</c>
          <c>0x0008</c>
          <c>Request no bypass:  Requests that servers not allow non-SQRL account recovery options.</c>
          <c>0x0010</c>
          <c>Warn of possible MITM attack: The client will warn the user if their IP doesn't match the server's expectations.</c>
          <c>0x0020</c>
          <c>Clear ShortPass when screen blanks: The client will securely erase any ShortPass information when the screen saver is activated or the system is going to suspend / sleep modes.</c>
          <c>0x0040</c>
          <c>Clear ShortPass when changing users: The client will securely erase any ShortPass information when the system's active user changes.</c>
          <c>0x0080</c>
          <c>Clear ShortPass after idle timer: The client will securely erase any ShortPass information after the system has been idle for an amount of time specified in the "Idle Timeout" option.</c>
          <c>0x0100</c>
          <c>Warn of non-CPS authentication: The client will warn the user before a non-CPS authentication is attempted.  This flag MUST default to on.</c>
        </texttable>
      </section>
      <section anchor="identity-storage" title="Identity Storage">
        <t>
          Because SQRL identities are intended to last the user's lifetime, 
          the user needs to be able to move his identity between clients.
          Every SQRL client MUST be able to read and write identities in this
          standard format.  The format described here is RECOMMENDED for both
          non-volatile and in-memory storage.  
        </t>
        <t>
          Because identities should be backed up offline (to printed paper),
          the storage format must be compact enough to reliably fit in a
          printed QR code, and short enough to not cause undue burden if
          the user has to type it in by hand.
        </t>
        <t>
          Values stored in standard SQRL storage format MUST follow these rules:
          <list style="symbols"><t>All numeric values are unsigned.</t><t>
              Multibyte numeric values are stored in little endian byte order,
              with the least significant byte first.
            </t><t>
              String values are stored in natural order, first byte first.
            </t></list>
        </t>
        <section title="Storage Blocks">
          <t>
            A stored SQRL identity is composed of any number of blocks.  Each block
            begins with a four byte header identifying the total length of the block 
            and the type of data stored in the block.
          </t>
          <texttable anchor="table-block-format" title="Storage Block Format">
            <ttcol>Field</ttcol>
            <ttcol>Size (bytes)</ttcol>
            <c>block length in bytes (n+4)</c>
            <c>2</c>
            <c>block type</c>
            <c>2</c>
            <c>block data</c>
            <c>n</c>
          </texttable>
          <t>
            Standard block types are defined in the next section.  Clients MAY add
            their own block types to store additional information, but SHOULD
            consider types 0-255 as reserved for future official block types.
            Any client reading an identity that encouters a block type unknown to
            that client MUST simply ignore that block.
          </t>
        </section>
        <section title="Predefined Block Types">
          <section anchor="type-1-block" title="Block Type 1: Working Identity">
            <t>
              The type 1 block contains the user's encrypted IMK and ILK, as well as 
              user defined options.  The user options are in plain text, but MUST be 
              regarded as untrusted until authenticated through AES-GCM.  Type 1
              blocks are encrypted with AES-GCM using the PWDK.  The type 1 block is 
              formatted as follows:
            </t>
            <texttable title="Type 1 Block">
              <ttcol>Field</ttcol>
              <ttcol>Default</ttcol>
              <ttcol align="right">Bytes</ttcol>
              <c>Block Length</c>
              <c>125</c>
              <c>2</c>
              <c>Block Type</c>
              <c>1</c>
              <c>2</c>
              <c>AAD Length</c>
              <c>45</c>
              <c>2</c>
              <c>AES-GCM IV</c>
              <c/>
              <c>12</c>
              <c>EnScrypt Salt</c>
              <c/>
              <c>16</c>
              <c>EnScrypt n-factor</c>
              <c>9</c>
              <c>1</c>
              <c>EnScrypt Iteration Count</c>
              <c/>
              <c>4</c>
              <c>User Option Flags</c>
              <c>0x01F3</c>
              <c>2</c>
              <c>ShortPass Length</c>
              <c>4</c>
              <c>1</c>
              <c>EnScrypt Seconds</c>
              <c>5</c>
              <c>1</c>
              <c>Idle Timeout (minutes)</c>
              <c>15</c>
              <c>2</c>
              <c>Encrypted IMK</c>
              <c/>
              <c>32</c>
              <c>Encrypted ILK</c>
              <c/>
              <c>32</c>
              <c>AES-GCM Verification Tag</c>
              <c/>
              <c>16</c>
            </texttable>
            <t>
              Constructing a type 1 block is relatively straight-forward:
              <list style="numbers"><t>Allocate a 125 byte buffer.</t><t>Populate the default values (or user chosen options).</t><t>Generate a random 12 byte initialization vector (IV) and store it in the buffer.</t><t>Generate a random 16 byte salt and store it in the buffer.</t><t>Use the generated salt, the user's password, and the user's chosen EnScrypt Seconds value to generate the PWDK and Iteration Count.</t><t>Populate the Iteration Count in the buffer.</t><t>AES-GCM encrypt the IMK and ILK (64 bytes total) using the first "AAD Length" bytes of the buffer as AAD, the IV, 
              the PWDK.</t><t>Populate the ciphertext result and verification tag from AES-GCM.</t><t>Securely wipe the plaintext keys, encryption key, and password from memory if they are no longer needed.</t></list>
              If the client is updating a type 1 block, and the user's password hasn't changed, 
              clients SHOULD use the original salt and iteration count to re-encrypt the block.
            </t>
          </section>
          <section anchor="type-2-block" title="Block Type 2: Rescue Identity">
            <t>
    The type 2 block contains a single key, the IUK, along with it's
    encryption parameters.  It is encrypted with AES-GCM using the RCDK.
  </t>
            <texttable title="Type 2 Block">
              <ttcol>Field</ttcol>
              <ttcol>Default</ttcol>
              <ttcol>Bytes</ttcol>
              <c>Block Length</c>
              <c>73</c>
              <c>2</c>
              <c>Block Type</c>
              <c>2</c>
              <c>2</c>
              <c>EnScrypt Salt</c>
              <c/>
              <c>16</c>
              <c>EnScrypt n-factor</c>
              <c>9</c>
              <c>1</c>
              <c>EnScrypt Iteration Count</c>
              <c/>
              <c>4</c>
              <c>Encrypted IUK</c>
              <c/>
              <c>32</c>
              <c>AES-GCM Verification Tag</c>
              <c/>
              <c>16</c>
            </texttable>
            <t>
    The type 2 block is constructed the same way as the type 1, with the following exceptions:
    <list style="symbols"><t>
        To save space in textual exports, we implicitly use a 12 byte, all zero Initialization Vector for AES-GCM.
        This means that the type 2 block MUST NOT be re-encrypted with different parameters.  This block MUST NOT
        be changed after identity creation.  It can only be replaced by rekeying.
      </t><t>The RCDK is used in place of the PWDK.</t></list>
  </t>
          </section>
          <section anchor="type-3-block" title="Block Type 3: Previous Identities">
            <t>
      The type 3 block contains from one to four of the most recent PIUKs, IUKs which have been replaced by rekeying.  
      It also includes the total number of times the identity has been rekeyed, the "Edition".  If the identity has 
      never been rekeyed, this block will be absent.  Encrypted using the IMK as the AES-GCM encryption key, the 
      content of this block is accessible to the client if either the user's password or the Rescue Code is known.
    </t>
            <texttable title="Type 3 Block">
              <ttcol>Field</ttcol>
              <ttcol>Default</ttcol>
              <ttcol>Bytes</ttcol>
              <c>Block Length</c>
              <c>54, 86, 118, or 150</c>
              <c>2</c>
              <c>Block Type</c>
              <c>3</c>
              <c>2</c>
              <c>Edition</c>
              <c/>
              <c>2</c>
              <c>Previous IUKs</c>
              <c/>
              <c>32, 64, 96, or 128</c>
              <c>AES-GCM Verification Tag</c>
              <c/>
              <c>16</c>
            </texttable>
            <t>
      The type 3 block is encrypted with AES-GCM, using the first 6 bytes of the block as AAD, the IMK as the encryption key,
      and a 12 byte all zero initialization vector (IV).  Due to the nature of the block's content, the same encryption key will
      never be used to encrypt a different set of data and AAD, so a random IV is not necessary.
    </t>
          </section>
        </section>
        <section title="Encoding">
          <t>
      Identities may be stored to file or optical (QR) code in binary
      format, or in base64url or base56check (<xref target="algo-b56c"/>) 
      encoded text.  Compatible clients MUST support at least one of 
      these standard encodings.
    </t>
          <t>
      Identities stored in this standard format MUST include an 8 byte
      header identifying the encoding used for the remainder of the file,
      with a single exception:  Identities exported to text using base56check
      encoding do not include a header.  Instead, they are validated by
      the encoded check characters.  The header itself is not encoded,
      but indicates that everything following it will be.
    </t>
          <texttable anchor="table-id-encoding" title="Storage Encodings and Headers">
            <ttcol>Encoding</ttcol>
            <ttcol>Header (ASCII)</ttcol>
            <c>binary</c>
            <c>sqrldata</c>
            <c>base64url</c>
            <c>SQRLDATA</c>
            <c>base56check</c>
            <c/>
          </texttable>
        </section>
      </section>
      <section title="Identity Operations">
        <t>
      Identity creation, recovery, and rekeying are particularly vulnerable times for the SQRL identity, during which
      several Class A secrets may be exposed.  Special care is required to protect this sensitive key during these operations.  
      Clients SHOULD inform the user of the security implications and encourage the user not to perform these operations
      on a device that the user believes to be compromised.
    </t>
        <section anchor="identity-creation" title="Identity Creation">
          <t>
        The SQRL identity is, in essence, just a long random number (the IUK).  In order to protect the new identity, 
        both during creation and against future exploits, the client MUST use the highest quality entropy available to 
        it while creating a new identity.  See <xref target="app-entropy"/> for recommendations on harvesting entropy.
      </t>
          <t>
        Creating an identity involves generating a random IUK and Rescue Code, deriving the IMK and ILK, and encrypting these
        keys.  In addition, the client MUST allow and encourage the user to store both the new identity and the Rescue Code in 
        an offline format.  The following process is RECOMMENDED:
        <list style="numbers"><t>Begin harvesting entropy if the client does not do this continuously.</t><t>Prompt the user to name their new identity so that they can recognize it later.</t><t>
            Generate a random Rescue Code, and have the user store the Rescue Code offline.  Written or printed form is RECOMMENDED.
            Encourage the user to securely store the Rescue Code in an offline format.  The client MAY require the user to retype
            the Rescue Code to ensure that they have stored a copy.
          </t><t>Prompt the user for a password to protect the new identity.  Clients SHOULD encourage the user to choose a strong password.</t><t>
            Generate a random IUK and store it in a newly constructed Type 2 block (<xref target="type-2-block"/>), encrypted with
            the newly generated Rescue Code.
          </t><t>
            Derive the IMK and ILK and store them in a newly constructed Type 1 block (<xref target="type-1-block"/>), encrypted with
            the user's new password.
          </t><t>Securely wipe any memory containing unencrypted keys or passwords.</t><t>Save the newly created blocks to local storage with the user chosen name.</t><t>Provide options for, and encourage the user to backup the new identity to an offline format.</t></list>
      </t>
        </section>
        <section anchor="identity-import-export" title="Importing / Exporting an Identity">
          <t>
          For compatibility, clients MUST support importing and exporting identities in at least one of these standard formats.  
          It is RECOMMENDED that clients support all of them.  Clients MAY offer additional formats as well.
          <list style="hanging" hangIndent="3"><t hangText="Binary File"><vspace/>
              An identity in the <xref target="identity-storage">standard format</xref>, saved as a binary file with the "sqrldata"
              header.  The RECOMMENDED file extension is ".sqrl".
            </t><t hangText="QR Code"><vspace/><list style="symbols"><t>TODO: Reference QR Code specification?</t><t>TODO: Recommend Mode, Encoding, Error Correction, etc.</t></list></t><t hangText="Text"><vspace/>
              An identity in the <xref target="identity-storage">standard format</xref>, encoded with 
              <xref target="algo-b56c">base56check</xref>, intended to be printed to paper for offline
              storage and manually entered by the user during import.
            </t></list>
        </t>
        </section>
        <section title="Changing the User's Password">
          <t>
          Clients SHOULD allow the user to change their password at any time.  The process is simple:
          <list style="numbers"><t>Using the user's current password, decrypt the Type 1 Block.  Other block types are not affected by this operation.</t><t>Using the user's new password, re-encrypt the Type 1 Block.  During encryption, EnScrypt MUST be called in Timer Mode, using
            the user's chosen "EnScrypt Seconds" option (<xref target="user-options"/>).</t><t>Save the changes to non-volatile storage.</t></list>
        </t>
        </section>
        <section anchor="identity-recovery" title="Identity Recovery">
          <t>
        If the user has forgotten their password, or lost their identity file, identity recovery is required to reconstruct 
        a usable identity.  Depending on the situation, the client may be recovering from an existing identity file, or from
        an offline backup.  In either case, the procedure is the same:
        <list style="numbers"><t>Because the user's options are lost in this process, the client SHOULD give the user an opportunity to review the default options and make changes.</t><t>Prompt the user to enter their Rescue Code and new password.</t><t>Validate the Rescue Code by decrypting the Type 2 block and obtain the IUK.</t><t>Derive the IMK and ILK, and construct a new Type 1 block protected by the user's newly chosen password.</t><t>Securely wipe any memory containing unencrypted keys or passwords.</t><t>Save the recovered identity.</t></list>
      </t>
        </section>
        <section anchor="identity-rekey" title="Rekeying an Identity">
          <t>
        Rekeying an identity completely replaces the IUK with a new one.  It is only required when the user believes that
        their identity may have been compromised.  After rekeying, the client SHOULD encourage the user to visit and authenticate
        with any important sites to ensure that those sites update their identity association.  Until this is done, an
        attacker may still have full access to those sites.  To rekey an identity:
        <list style="numbers"><t>Prompt the user for their Rescue Code.</t><t>Using the Rescue Code, decrypt the Type 2 block to obtain the IUK (now a PIUK).</t><t>
            Follow the steps in <xref target="identity-creation"/> to create a new identity.
          </t><t>
            Before saving or exporting the new identity, a Type 3 block (<xref target="type-3-block"/>) must be constructed:
            <list style="letters"><t>If a Type 3 block already exists (rekeying has been performed in the past), the existing block must be decrypted and
              modified.  The "Edition" field is incremented, and the new PIUK is prepended to the existing PIUKs.  If the list
              now contains more than four PIUKs, the last (oldest) one is removed.</t><t>If a Type 3 block does not already exist, a new one is created.  Fill the "Edition" field with the number 1.  The
              encrypted section will contain only the new PIUK.</t><t>Encrypt the Type 3 block using the new IMK and ensure that it is saved / exported with the new identity.</t></list>
          </t></list>
      </t>
        </section>
      </section>
    </section>
    <section title="Client-Server Protocol">
      <t>TODO</t>
      <section title="Initiation of SQRL Authentication">
        <t>TODO</t>
        <section title="The SQRL Scheme">
          <t>TODO</t>
        </section>
        <section title="QR Codes (Out of Band)">
          <t>TODO</t>
        </section>
      </section>
      <section anchor="section-realm" title="The SQRL Realm (Domain)">
        <t>TODO</t>
      </section>
      <section title="Client to Server Requests">
        <t>TODO</t>
        <section title="Protocol Version">
          <t>SQRL protocol versions are specified by integers starting at 1.</t>
          <t>Both client and server MUST declare the set of SQRL protocol versions it understands, supports, and is willing to use. This protocol version declaration MUST be the first name=value pair appearing in the argument list and MUST be one of the following formats:
          <list style="symbols">
            <t>A single supported version (e.g., "ver=1", signifying that only version 1 of the SQRL protocol is supported)</t>
            <t>Multiple supported versions via a comma-separated list (e.g., "ver=1,3", signifying that versions 1 and 3 of the SQRL protocol are supported, but not 2)</t>
            <t>A range of versions via hyphenation (e.g., "ver=1-3", signifying that versions 1, 2, and 3 of the SQRL protocol are supported)</t>
            <t>A combination of these techniques (e.g., "ver=1-3,5", signifying that versions 1, 2, 3, and 5 of the SQRL protocol are supported, but not 4)</t>
          </list></t>
          <t>Once both client and server have declared their supported version sets, the version used MUST be the highest version number in the intersection of these sets.</t>
        </section>
        <section title="Commands">
          <t>TODO</t>
        </section>
        <section title="Options">
          <t>TODO</t>
        </section>
        <section title="The Server Value">
          <t>The server gives data to the client in two ways: encoded into the SQRL URL, where it provides the "nut=" session identifier and the optional "x=" domain extension, and the HTTP response bodies where any of the following parameters may be used.</t>
          <t>When appearing in a URL, name=value pairs MUST be URL-safe and ampersand separated as per standard HTTP GET syntax. When returned as a response to a client's query, the name=value pairs occupy the body, one per line with each (including the last one) terminated by CRLF.</t>
          <t>There MUST NOT be any space between either the name or value and the equal sign.
          <list style="hanging">
            <t hangText="ver"><vspace/>The server MUST declare the set of supported protocol versions, and this declaration MUST be first in the client's argument list. See <xref format="title" target="ver" />.</t>
            <t hangText="nut"><vspace/>Base64url-encoded opaque token that is a never-repeating cryptographically-strong nonce. The nut MAY contain reversibly encrypted data to help the server associate and maintain state. It MUST be included with every response to prevent reuse/replay and hijacking attacks. As with all of SQRL's base64 values, any trailing equals signs must be stripped. [add xref here once section on nut is complete]</t>
            <t anchor="tif" hangText="tif"><vspace/>Transaction Information Flags. A single hexadecimal-encoded integer that MUST be included in every server response. The "0x" prefix is included here for clarity, but they are not needed or used in the TIF's value.</t>
            <texttable align="center" style="all" title="Transaction Information Flags (TIFs)">
              <ttcol align="right">Flag</ttcol>
              <ttcol align="left">Description</ttcol>
              <c>0x01</c><c>(Current) ID Match. Indicates that the server has found an identity association for the user based on the current IDK and IDS supplied by the client.</c>
              <c>0x02</c><c>Previous ID Match. Indicates that the server has found an identity association for the user based on the PIDK and PIDS. When neither of the ID bits are set, none of the credentials supplied are known to the web server.</c>
              <c>0x04</c><c>IP Match. Indicates that the IP address of the client matches the IP address of the initial logon page containing the SQRL URL.</c>
              <c>0x08</c><c>SQRL Disabled. Indicates that the SQRL authentication for this identity has previously been disabled. While this bit is set, any attempt at authentication MUST fail. This bit can ONLY be reset, and the identity re-enabled, by the "enable=" parameter from the client signed by the URS for the identity known to the server.</c>
              <c>0x10</c><c>Function(s) Not Supported. The client requested one or more SQRL functions that the server does not currently support. The server MUST also fail the query by setting 0x40 Command Failed.</c>
              <c>0x20</c><c>Transient Error. Indicates that the client signature(s) are correct, but something about the query prevented the command from completing. MUST be accompanied by a fresh "nut=" and a new "qry=" parameter. The server is requesting that the client retry and reissue the command with the new nut and query values. The server MUST also fail the query by setting 0x40 Command Failed.</c>
              <c>0x40</c><c>Command Failed. Indicates that the server has had a problem processing the client's query. No change is made to the user's account or login status. With SQRL, either everything succeeds, or nothing happens. When set without 0x80 Client Failure, the trouble was not with the client's data, protocol, etc. but with some other aspect of the request failing. The server MAY use the "ask=" parameter to explain the problem to the client's user. When this flag is activated, the client MUST consider all other TIFs other than 0x80 to be invalid.</c>
              <c>0x80</c><c>Client Failure. Some aspect of the client's submitted query (other than expired but otherwise valid state information) was incorrect and prevented the server from understanding and/or completing the requested action. Moreover, this is not an issue the server expects could be fixed by having the client reissue the command with a fresh nut. The server MUST also set 0x40 Command Failed.</c>
              <c>0x100</c><c>Bad ID Association. The server may request reverification of the user's SQRL identity after a successful authentication. If it then receives a SQRL query using that nut but with a different SQRL identity, the server MUST reply with 0x100 Bad ID Association along with 0x40 Command Failed and 0x80 Client Failure.</c>
            </texttable>
            <t>Note that the number of characters in the "tif=" value may vary depending on the number of characters required to represent the most significant bit set within the value. Later versions of the SQRL protocol may expand this list as needed. Therefore, there MUST NOT be any restrictions on or assumptions about the length of the "tif=" value.</t>
            <t>SQRL clients MUST immediately terminate any connection and abort any authentication operation with any SQRL server that includes TIF bits not defined.</t>
            <t hangText="qry"><vspace/>The query path. Instructs the client to query the provided server object in its next query (if any). MUST be included in every reply. MUST contain the full path from the root ("/"), and MUST NOT contain the scheme, domain name, or port.</t>
            <t hangText="url"><vspace/>Redirection URL. MUST be provided in response to any command other than "query" when the SQRL client's query includes the "opt=cps" parameter. The server MUST NOT authenticate the current web browser sessio, but instead uset his parameter to provide the client with a URL taking the user to a page showing the result of the authentication.</t>
            <t hangText="sin"><vspace/>The Secret INdex. The server MAY include this parameter to request an identity-based, high-entropy, 256-bit indexed secret from the client. The client will hash this value via a secondary identity-keyed HMAC256. Servers MAY request any number of indexed secret values. SHOULD contain a cryptographically-secure degree of entropy.</t>
            <t hangText="suk"><vspace/>Server Unlock Key. When the server receives a successful authentication on a PIDK, or when the existing SQRL account is disabled, the server MUST provide the SUK to the client so that the client may either re-enable the user's account, update the user's identity, or remove the user's account entirely.</t>
            <t hangText="ask"><vspace/>A simple but flexible means for a remote server to gain a response from the SQRL client's user. The value MUST contain the base64url-encoded text to display to the user, and MAY contain one or two button parameters separated by tildes. If no buttons are specified, a simple "OK" button will be displayed to the user. A button parameter consists of base64url-encoded text to display in the button, and MAY be followed by a semicolon delimiting a URL. If the user selects a button where a URL is provided, the SQRL client will submit the link to its host operating system for handling. All text MUST be UTF-8 encoded to support international characters.</t>
            <t hangText="can"><vspace/>OPTIONAL CANcellation redirection URL. If "opt=cps" is set but the authentication is aborted by the user and this value is present, the SQRL client will redirect the pending browser page to the URL specified in this parameter.</t>
          </list></t>
          <t>The server MAY include additional name=value pairs not defined to support extensions to the SQRL protocol. Any undefined "name=" parameter SHOULD simply be ignored.</t>
        </section>
        <section title="The Client Value">
          <t>The "client=" parameter contains a base64url encoded list of name=value pairs, one per line, with each line terminated by a CRLF character pair. The client assembles a list of the name=value pairs to return data to the web server, to specify one or more command actions it is requesting from the server, and to provide any cryptographic keying material required to authorize the requested actions and/or authenticate its user's identity.
          <list style="hanging">
            <t hangText="ver"><vspace/>The client MUST declare the set of supported protocol versions, and this declaration MUST be first in the client's argument list. See <xref format="title" target="ver" />.</t>
            <t hangText="cmd"><vspace/>Specifies the action the client is requesting from the server. See <xref format="title" target="cmd" />.</t>
            <t hangText="opt"><vspace/>An unordered list of transaction options, separated by tildes. See <xref format="title" target="opt" />.</t>
            <t hangText="btn"><vspace/>When receiving an "ask" query from the server, the client displays the query to the user. Once the user responds, the client MUST include the "btn" parameter with the character "1" or "2" depending on which button the user selected. If the prompt was acknowledged without selecting either button, "btn=3" is returned.</t>
            <t hangText="idk"><vspace/>The IDentity Key. This is the user's SSPK which uniquely identifies them to the realm. See <xref format="title" target="IDK" />.</t>
            <t hangText="pidk"><vspace/>The Previous IDentity Key. When a user has rekeyed their identity, it must be updated on any server the user has not visited since the rekeying. During one or more queries, the client will present the server with the user's current IDK and the previous PIDK along with its matching signature. This process MUST be repeated for each PIDK until either the authentication is successful and the IDK updated, or until the client runs out of PIDKs, causing the authentication to fail.</t>
            <t hangText="suk"><vspace/>The <xref target="SUK">Server Unlock Key</xref>. Included in every query where the immediately previous server reply did not have the 0x01 bit of its TIF flags set. See <xref target="tif">Transaction Information Flags (TIFs)</xref>.</t>
            <t hangText="vuk">The <xref target="VUK">Verify Unlock Key</xref>. Generated along with and always accompanies the SUK. [Add reference to TIF once that section is written]<vspace/></t>
            <t hangText="ins"><vspace/>The INdex Secret. When the immediately previous server reply contains a "sin" parameter, the user's <xref target="SSSK">SSSK</xref> is passed through <xref target="algo-enhash">EnHash</xref> and used to key a secondary HMAC256 to hash the server's "sin" value. The output is base64url encoded and sent as the value for the "ins" parameter.</t>
            <t hangText="pins"><vspace/>The Previous INdex Secret. When the authentication was made using a PIDK, the client MUST include the corresponding PINS, calculated the same way as the INS, in its query.</t>
            <t hangText="ids"><vspace/>The IDentity Signature. Authenticates the contents of the query block to the server. The SSSK is used to sign the concatenated values of the client and server prarameters.</t>
            <t hangText="pids"><vspace/>The Previous IDentity Signature. Used when authentication was made using a PIDK.</t>
            <t hangText="URS"><vspace/>Unlock Request Signature. When an account is locked, the server sends the SUK to the client, the client's IUK is used to generate the unlock request. The URS is the result of DHKA ( SUK, IUK ).</t>
          </list></t>
          <t>The client MAY include additional name=value pairs not defined to support extensions to the SQRL protocol. Any undefined "name=" parameter SHOULD simply be ignored.</t>
          <section anchor="cmd" title="Command Tokens">
            <t><list style="hanging">
              <t hangText="query"><vspace/>Queries are generally initiated after the user verifies the domain name and decrypts his identity with his Master Password. The client uses the query to provide the user's IDK and optionally one or more PIDKs. The server response with TIF codes indicating the status of the request.</t>
              <t hangText="ident"><vspace/>A query is usually followed by an ident. The query allows the client to obtain requested information from the server; the ident requests that the web server accept the user's identity assertion.</t>
              <t hangText="disable"><vspace/>Activates the SQRL Identity Lock feature for this server.</t>
              <t hangText="enable"><vspace/>Re-enables the user's SQRL identity after it has been locked. The client will receive the SUK in a server response so that it can generate the Unlock Request Signature necessary to unlock the identity.</t>
              <t hangText="remove"><vspace/>Instructs the server to immediately remove all trace of this SQRL identity from the server. Different from disable in that it allows a change to an unassociated identity.</t>
            </list></t>
          </section>
          <section anchor="opt" title="Options">
            <t><list style="hanging">
              <t hangText="noiptest"><vspace/>Instructs the server to disable same-IP verification. Results in the 0x04 "IPs matched" TIF to be activated even if the IP addresses did not match. Used when the client knows the link was received from a remote device (e.g., when a QR code was scanned).</t>
              <t hangText="sqrlonly"><vspace/>Requests that the server disable any alternative non-SQRL autentication methods such as username/password authentication.</t>
              <t hangText="hardlock"><vspace/>Disables "out of band" changes to the user's SQRL identity such as security questions and email resets.</t>
              <t hangText="cps"><vspace/>Client Provided Session. Informs the server that the client has a secure and private means of returning a server-supplied URL to the web browser after successful authentication.</t>
              <t hangText="suk"><vspace/>Requests that the server return the user's Server Unlock Key so that the identity can be unlocked or rekeyed.</t>
            </list></t>
          </section>
        </section>
        <section title="Client Keys">
          <t>TODO</t>
        </section>
        <section title="Client Signatures">
          <t>TODO</t>
        </section>
        <section title="Composing the Request">
          <t>TODO</t>
        </section>
      </section>
      <section title="Server to Client Replies">
        <t>TODO</t>
        <section title="Required Values">
          <t>TODO</t>
        </section>
        <section title="Optional Values">
          <t>TODO</t>
        </section>
        <section title="Additional Values">
          <t>TODO</t>
        </section>
        <section title="Composing the Reply">
          <t>TODO</t>
        </section>
      </section>
    </section>
    <section title="Client-Server Interactions">
      <t>TODO</t>
      <section anchor="same-device" title="Same Device Authentication">
        <t>TODO</t>
      </section>
      <section anchor="cross-device" title="Cross Device Authentication">
        <t>TODO</t>
      </section>
      <section title="Identity Association">
        <t>TODO</t>
      </section>
      <section title="Updating Identity Association">
        <t>TODO</t>
      </section>
      <section title="Disabling Site Login">
        <t>TODO</t>
      </section>
      <section title="Re-Enabling Site Login">
        <t>TODO</t>
      </section>
    </section>
    <section anchor="IANA" title="IANA Considerations">
      <t>TODO</t>
    </section>
    <section anchor="Security" title="Security Considerations">
      <t>As SQRL aims to protect a single identity that is ultimately used to authenticate a user everywhere, the security of this identity is paramount. Further, users must face many of the same security issues as with traditional methods of authentication.</t>
      <t>It is important to consider the following attack goals:<list style="numbers"><t>Session hijacking</t><t>Site credential theft</t><t>Association of SQRL identity to site account</t><t>Master key theft</t><t>Breaking of pseudonymous nature of SQRL authentication (association of SQRL identities on various sites)</t></list></t>
      <section title="Phishing">
        <t>One well-known attack mode is where the user is invited to click on a link appearing to go to a legitimate site, but is in reality directed to an attacker's server.</t>
        <t>One common method of this is a look-alike link. For example, a user believing he is going to example.com is in reality going to examp1e.com (the lowercase "l" is replaced with a numeral "1"). A historical example is "tvvitter.com" (the letter "v" twice instead of a "w").</t>
        <t>Another method is to use a malformed URL to misdirect a user. For example, this link:</t>
        <t>https://www.amazon.com@%67%72%63.%63%6f%6d/</t>
        <t>at first glance appears to be a link to Amazon, but in reality takes the user to grc.com. In a real-world attack, the attacker would substitute the name of his phishing site and most users might be fooled entirely.</t>
        <t>Another technique known as "Punycode" exploits the display of UTF-8 characters to hide the true ASCII text of the domain name. For example, it might substitute Cyrillic characters (e.g., U+430 which looks similar or identical to the ASCII "a", U+0061), or it may use the ASCII equivalent of the bytes making up the unicode string (e.g., a domain appearing as "apple.com" is really "xn-80ak6aa92e.com"). Browsers may even show the bogus domain in the address bar, giving the user no opportunity to realize they are being fooled. For more information, see <xref target="Zheng">Xudong Zheng, "Phishing with Unicode Domains."</xref></t>
        <t>The phishing site is generally set up to look and work exactly the way the real site works, at least up until the point where the attacker has stolen the desired data.</t>
        <t>Phishing attacks where the goal is to obtain authentication credentials are entirely foiled by SQRL. Since SQRL uses the domain name as the basis for authentication, it will create completely different identity keys. The IDK the attacker gets will be a public key specifically for his attack site, useless to him for obtaining access to the real site.</t>
        <t>However, the attacker may have other goals. If the attacker can successfully mimic a banking or e-commerce site, the user could be tricked into entering account data such as a credit card number. SQRL clients MUST display the real domain name to the user in a font with unambiguous glyphs before any authentication occurs, giving them the opportunity to realize they are being fooled.</t>
        <t>Many phishing attacks are pass-through attacks, where the phishing site acts as an active Man-In-The-Middle. It obtains the genuine page from the real site and passes it along to the user, receiving the user's responses and passing them back to the site. In the case of <xref target="same-device">same-device authentication</xref>, the client will be warned of an IP mismatch, and CPS will redirect the browser to a safe page on the real site. No such protections exist for <xref target="cross-device">cross-device authentication</xref>, but this is generally used in the case of untrusted devices where the user will probably be typing in the domain name manually.</t>
        <t>The attacker can get around SQRL's protections with DNS spoofing, where the device's DNS addresses are altered, entries are added to the hosts file, or otherwise made to redirect a host name to an incorrect address, generally the phishing site controlled by the attacker. In such a case, SQRL would be fooled (as would anything else on the compromised device).</t>
        <t>However, cross-device authentication would foil this, as the user would be using a smartphone or other trusted device that would be doing its own DNS lookup. Local authentication should take place only on trusted devices. DNS could only be spoofed on these devices using malware, but malware can compromise any security feature.</t>
        <t>A SQRL client MAY employ an additional protection from such an attack in the form of an internal DNS resolver, bypassing the attacker's spoofing. However, such a feature may not be desired on enterprise networks running their own internal DNS systems, so the SQRL client MUST give the user a configuration option to disable the internal resolver and use the OS resolver as per normal.</t>
      </section>
      <section title="Shoulder-Surfing">
        <t>In the context of SQRL, the danger is of an attacker scanning the QR code of a SQRL-enabled website. With good timing, the attacker could fool the user into thinking he's logged in as himself when in reality he's authenticated to an account controlled by the attacker. The attacker could then get anything the user enters into that web site, including credit card numbers and other sensitive information.</t>
        <t>Shoulder-surfing is when an attacker reads or scans the display, keyboard, and other components of the target's device directly, allowing the attacker to see sensitive information, including information entered into forms.</t>
        <t>However, in such a case the user's authentication would fail as the nut is no longer valid. The SQRL client MUST deliver an error message to the user saying that the authentication has failed, and SHOULD advise the user of the dangers of continuing to use the web site, especially if the authentication has the appearance of having worked.</t>
        <t>Care should be taken when authenticating to a website in a public area, or any other place where others could see the QR code or watch the user type the Master Password on the keyboard. Keep in mind that these can be picked up using binoculars or seen on a CCTV camera.</t>
        <t>It is absolutely crucial that a new SQRL identity NOT be created, and an existing one NOT be rekeyed, in such an area. Anyone who can resolve the screen and keyboard can get the Master Password, the full identity backup, AND the Rescue Code.</t>
      </section>
      <section title="Evil Router">
        <t>In this context, the router in consideration is the one connecting the user's LAN segment to the rest of the Internet. Home routers have been shown to be lacking in security, and even a well-supported router must be updated when new firmware versions are released, something most users aren't aware of.</t>
        <t>It is also increasingly the case that users connect to Wi-Fi hotspots when travelling, relying on routers whose security they could not evaluate even if they knew to. Moreover, an attacker on the LAN segment could engage in ARP spoofing to make the attacker's own device the default gateway for the segment, forwarding the packets on to the true router but establishing himself as a Man-In-The-Middle.</t>
        <t>Once an attacker gains control of the default gateway, he could engage in phishing and DNS spoofing attacks as described above. More significantly, he could insert himself into the TLS handshake and commit any number of attacks designed to compromise the security of TLS.</t>
        <t>SQRL provides no means of defending the user against such an attack, however, at most the attacker will gain access to the specific login sessions the user makes while at that location.</t>
      </section>
      <section title="Server Compromise">
        <t>A server compromise can result in sensitive user data being obtained by the attacker without the user even logging in.</t>
        <t>In the case of SQRL there is less critical data for the attacker to get. There are no passwords or other secrets sent to the server that have to be hashed and protected. The attacker can only get the IDK, SUK, and VUK, which are useless to him.</t>
        <t>If the attacker obtained write access, he could conceivably generate a new SUK and VUK based on his own IUK and take control of the account via the Identity Lock protocol. However, if the attacker already has write access there would be little more to gain by doing so in most situations.</t>
        <t>If the attacker has gained access to more than one site, the IDK would be different, meaning that the attacker could not correlate user data between websites (unless, of course, there was other identifying information in common such as an email address).</t>
        <t>All the same, once authenticated the user is subject to all of the harms that can occur regardless of the form of authentication.</t>
      </section>
      <section title="CPU Flooding">
        <t>CPU flooding is where the attacker is able to cause one or more processes to run that take up significant CPU time. It also can happen absent a malicious attack, when a normal CPU-intensive process starts running in the background.</t>
        <t>With SQRL, this can be a vulnerability when running <xref target="algo-enscrypt">EnScrypt</xref> in Timer Mode. After 5 seconds (by default), the timer runs out, and the resulting key is used to encrypt the identity and the number of iterations recorded. If another process utilizes significant CPU clocks during this process, the total number of iterations will be lower than it would have, meaning that the Master Password has weaker protection against cracking.</t>
      </section>
      <section title="Evil Client">
        <t>An evil client is a maliciously-developed SQRL client. It may take the form of its own client, or it may mimic an existing and trusted SQRL client. It may enter the user's computer in the form of malware, hijacking the sqrl:// protocol as a new handler and attaching itself to the localhost:25519 port. If artfully done, the user would have no clue that a substitution has been made.</t>
        <t>The consequences cannot be overstated. The evil client would be able to gain the unencrypted IMK on its very first use, allowing the attacker to be able to hijack ANY account on ANY website where the user has authenticated using SQRL.</t>
        <t>Moreover, it could keep track of everywhere the user logs in and send to the attacker all of the user's accounts on banking, e-commerce, and other important websites. And although a user can rekey his identity, he would first have to understand that his identity has been compromised.</t>
        <t>The absolute worst case scenario would be when a user uses an evil client to create or rekey his identity, which would give the attacker access to even the Rescue Code. All other possible security concerns pale to this.</t>
        <t>SQRL mitigates this possibility by requiring (and advising) only that the user place his SQRL identity on trusted devices, using cross-device authentication on all other devices. However, this only limits the attack surface. In the past, fake versions of Firefox and other web browsers, fake Bitcoin wallets, and numerous others have been downloaded by users and even placed inside the trusted app stores for Android and iOS. A malicious SQRL app, sadly, is not out of the question.</t>
        <t>This issue can be somewhat mitigated by requiring that SQRL apps be certified by trusted authorities. The reference implementation from GRC not only checks the certificate on every update, but checks the fingerprint on the DigiCert root certificate as well to help ensure that there was no improper substitution. However, the ultimate protection can only come from complete SQRL integration into web browsers and operating systems, which will refuse to let any other software hijack the sqrl:// protocol and eliminate the need for a localhost connection on port 25519.</t>
      </section>
    </section>
  </middle>
  <!--  *****BACK MATTER ***** -->
  <back>
    <!-- References split into informative and normative -->
    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->
    <references title="Normative References"><!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC2104;
      &RFC2119;
      &RFC2898;
      &RFC3548;
      &RFC3986;
      &RFC7914;
      &RFC8031;
      &RFC8032;
      <reference anchor="FIPS.180-4.2015"><front><title>Secure Hash Standard</title><author><organization>National Institute of Standards and Technology</organization></author><date year="2015" month="August"/></front></reference>
      <reference anchor="NIST.800-38D"><front><title>NIST Special Publication 800-38D: Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC.</title><author initials="M." surname="Dworkin"><organization>U.S. National Institute of Standards and Technology</organization></author><date month="November" year="2007"/></front></reference>
    </references>
    <references title="Informative References">
      &RFC4868;
      <reference anchor="Zheng" target="https://www.xudongz.com/blog/2017/idn-phishing/"><front><title>Phishing with Unicode Domains</title><author initials="X." surname="Zheng"/><date month="April" year="2017"/></front></reference>
      <reference anchor="Shamir"><front><title>How to share a secret</title><author initials="A." surname="Shamir"/><date month="November" year="1979"/></front><seriesInfo name="DOI" value="10.1145/359168.359176"/></reference>
      <reference anchor="Klyubin" target="https://android-developers.googleblog.com/2013/08/some-securerandom-thoughts.html"><front><title>Some SecureRandom Thoughts</title><author initials="A." surname="Klyubin">
          </author><date month="August" year="2013"/></front></reference>
    </references>
    <section title="Recommendations and Best Practices">
      <section title="Logo">
        <t>For ease of user understanding and recognition, a SQRL logo has been designed and released into the public domain. Clients SHOULD use this as the program logo, and servers SHOULD use this for the clickable link. The standard colors are a white SQRL figure against a background color of #007CC3 (CMYK: 100/20/0/0). Clients and servers MAY recolor the logo to suit the look of themes and skins. <eref target="https://www.grc.com/sqrl/logo.htm"></eref></t>
      </section>
      <section title="Font">
        <t>Museo Slab MAY be used by client and server developers desiring a consistent look across disparate SQRL implementations. <eref target="https://www.exljbris.com/museoslab.html"></eref></t>
      </section>
      <section anchor="app-client" title="For Clients">
        <t>TODO</t>
      </section>
      <section anchor="app-server" title="For Servers">
        <t>TODO</t>
      </section>
      <section anchor="app-user" title="For Users">
        <t>Disclaimer: None of this is intended to be any sort of legal advice, or indeed any guarantee that problems involving SQRL clients and identities will be minimized. They are designed to apply to most SQRL users in most situations most of the time. It should be up to each individual's discretion to determine whether or not particular recommendations make sense to their situation.</t>
        <section title="Master Password">
          <t>Traditionally, security experts have advised having unique passwords for every resource. The reason why is so that one resource being compromised will not threaten others. However, in the case of a single SQRL identity copied to multiple devices, a compromise of any of these identities would give an attacker full access to all SQRL-enabled logins, so the user gains nothing from protecting their SQRL identity on different devices with different passwords. But when users are asked to create different passwords, they generally pick weaker, formulaic passwords that are easier to remember.</t>
          <t>For this reason, it makes sense to have a single strong password protecting all copies of the user's SQRL identity.</t>
        </section>
        <section title="Identity Backup">
          <t>It is crucial that the user not lose his or her identity, as that would lock them out of any and all needed resources. Keeping a secure backup is essential.</t>
          <t>SQRL clients generally do not distinguish between exporting and backing up an identity, whether done by file, QR code, or text. But conceptually, exporting an identity is done with the intent to import it into another client in a timely manner. Therefore, exporting generally includes the identity encrypted with the Master Password.</t>
          <t>Backups, on the other hand, are intended for longer-term storage. The encryption on them therefore needs to be more secure than perhaps will be the case with the user's Master Password, which may be forgotten in the interim anyway. Therefore, when making a backup of an identity, it should be made without the Master Password, containing only a copy of the encrypted IUK from which the identity can be regenerated. The user would therefore need the Rescue Code to restore the backup.</t>
          <t>Note that text backup MUST NOT be exported with the Master Password.</t>
        </section>
        <section title="Disaster Recovery">
          <t>A user putting together his or her Last Will and Testament will want the executor(s) of their estate to be able to easily access all important assets. Since probate attorneys consider the security of all of this information to be paramount, it is recommended that they be given a hard copy of the SQRL client, exported without password, using the "data entry" method. The Rescue Code must also be included. The information must be updated whenever the user creates a new SQRL identity or rekeys an existing one.</t>
          <t>If the use of a probate attorney isn't desirable (e.g., the user lives in a country with no recognition of attorney-client privilege), SQRL's "data entry" export and the associated Rescue Code could be distributed through the person's heirs via <xref target="Shamir">Shamir's Secret Sharing.</xref></t>
        </section>
      </section>
    </section>
    <section anchor="app-shortpass" title="The Optional ShortPass Feature">
      <t>TODO</t>
    </section>
    <section anchor="app-entropy" title="Harvesting Entropy">
      <t>Secure cryptographic systems depend on the ability to create quality random numbers, and SQRL is no different in this regard. SQRL's needs are meager compared to many other functions and protocols, but critical.</t>
      <t>The use of a pseudo-random function to generate random numbers is only as good as the entropy it is seeded with. As RFC4086 points out, a hacker may find it easier to reproduce the environment a PRF was running in when it produced the secret quantities than to make blind guesses through the search space. [RFC4086]</t>
      <t>Optimally, the numbers used for seeding cryptographic functions such as Curve25519 should be truly random, but what constitutes "truly random" is regarded as much philosophy as computer science. However, a good working definition of "truly random" is one where the amount of entropy in a number is equal to its length; e.g., a 256-bit number that contains 256 bits of entropy.</t>
      <t>Unfortunately, determining the amount of entropy in an information stream is tricky at best. But entropy is never reduced as more information is added; even weak sources of entropy, when added together, can produce sufficient entropy. For that reason, none of the data collected during entropy harvesting should be discarded.</t>
      <t>The method recommended by SQRL is to harvest as much entropy as possible from as many uncorrelated sources as possible in the time available, and run the data stream through SHA-256 or SHA-512, depending on how much randomness is needed. The Secure Hashing Algorithm should change half the bits of the output when just a single bit of the input is changed, so the entropy should be preserved up to the length of the resulting hash. The technique, then, is to hash an amount of data where the entropy content almost certainly far exceeds 256 or 512 bits. These amounts are fairly trivial.</t>
      <t>For more about entropy harvesting, see RFC4086.</t>
      <section title="Entropy Sources">
        <t>Sources of entropy vary greatly depending on the hardware, operating system, and other aspects of the client device.</t>
        <section title="Operating System">
          <t>All operating systems have a source of randomness available (e.g., /dev/random on UNIX-like systems), but developers should think twice before relying solely on these. Flaws and backdoors could result in a false sense of security. For example, in 2013 a flaw in Android's SecureRandom function made Bitcoin wallets generated on those devices vulnerable to remote hacking and the theft of funds, even without access to the device.<xref target="Klyubin"/></t>
          <t>Developers should also be advised that many of these use some of the same techniques described below, meaning that utilizing the same technique might not result in as much entropy as estimated.</t>
        </section>
        <section title="Hardware">
          <t>Hardware sources can be very effective at harvesting entropy, but care must be taken to make sure that they exist on a particular implementation, and that the hardware hasn't failed in some way.</t>
          <t>The system clock has traditionally been used as a source of randomness, although it must be considered that users are more likely to generate the random numbers at some times of the day than others. Subseconds provide the greatest entropy here.</t>
          <t>Some systems come with embedded hardware that produce noise specifically for the purpose of seeding PRFs.</t>
          <t>Wireless networking devices can be polled for signal strength and other data.</t>
          <t>Processor statistics can be a significant source, such as cache hits/misses and other low-level system counters, voltage, fan speed, and thermal data.</t>
          <t>Sound from a microphone could be a source of high-quality entropy in a typical room with air conditioning, fans, and other source of noise, as well as interference on the sound channel. In such a case, a fraction of a second--less than two hundredths--would be sufficient, but as there is no guarantee longer periods should be considered.</t>
          <t>One or two frames from a camera can likewise be a source of high-entropy noise because of the sensor, which is especially the case if the SQRL client can set the camera's ISO to a high number. Most cell phones in particular have cameras that generate sufficient noise in the low-order bits. A single 640x480 frame would likely be sufficient for SQRL's purposes, although higher resolutions tend to be noisier. Care must be taken to ensure the client is getting the raw camera data, not compressed data which may have much of the noise removed.</t>
          <t>Free bytes of memory and storage space can vary quite a bit, adding a not insignificant amount of entropy.</t>
          <t>Network statistics, such as packet arrival time, can be effective, but only if it can be ensured that these are not subject to manipulation.</t>
        </section>
        <section title="User">
          <t>The user can provide a good measure of entropy, either directly by the client engaging the user, or indirectly.</t>
          <t>Examining mouse movements or keyboard strokes can be a source of entropy, although how much is a matter of some debate.</t>
          <t>Accelerometer data on cell phones and other such devices can pick up minute movements of the user's hand, even if the user is trying to hold it steady.</t>
        </section>
      </section>
    </section>
  </back>
</rfc>
